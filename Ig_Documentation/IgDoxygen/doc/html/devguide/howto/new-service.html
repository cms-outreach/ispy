<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN">

<html>
<head>
<link rel="home" href="http://iguana.cern.ch/">
<link rev="made" href="mailto:iguana-developers@cern.ch">
<link rel="stylesheet" href="../../weblayout.css" type="text/css">
<meta name="originator" content="IGUANA Developers">
<meta http-equiv="Reply-to" content="iguana-developers@cern.ch">
<meta http-equiv="Keywords" content="LHC, CMS, IGUANA, interactive,
  graphics, visualisation, toolkit, event display, OpenGL, OpenInventor,
  how to, create service">

<title>IGUANA Developer Guide: How To Create a Service</title>
</head>

<body bgcolor="#ffffff">
<table width="100%" border="0" cellspacing="0" cellpadding="0">
<tr>
 <!-- Top icon: fixes navigation bar width -->
 <td align="left" valign="top"><table width="100%" border="0">
  <tr><td><img src="../../images/pad.gif" width="20" height="1" alt=""></td>
   <td valign="top"><img src="../../images/mini.gif" width="98" height="64"
     border="0" alt="Yo!"></td>
   <td><img src="../../images/pad.gif" width="70" height="1" alt="*"></tr></table></td>

 <!-- Top banner: title -->
 <td colspan="2"><table border="0" width="100%" cellspacing="0" cellpadding="0">
  <tr><td align="left" colspan="2"><font face="Arial, Helvetica" size="-1">
     <font color="#FF00FF">I</font><font color="#009900">nteractive</font>
     <font color="#FF00FF">G</font><font color="#009900">raphics</font>
     <font color="#009900">For</font>
     <font color="#FF00FF">U</font><font color="#009900">ser</font>
     <font color="#FF00FF">ANA</font><font color="#009900">lysis</font>
     <font color="#0020FF">(Version @VERSNUM@)</font></td></tr>
  <tr valign="bottom"><td align="left"><img src="../../images/title.gif" width="208"
    height="62"  border="0" alt="IGUANA"></td>
   <td align="right"><font face="Arial, Helvetica" size="+2"><b>
    Developer Guide: How To<br>Create an Application Service</b></font></td></tr>
  <tr><td colspan="2" align="left"><hr align="left" noshade="noshade"></td></tr>
 </table></td></tr>

<tr valign="top"><td>
 <!-- Left context navigation bar. -->
 <!-- Navigation button row. -->
 <table width="100%" border="0" cellspacing="0" cellpadding="0">
  <tr>
   <td align="left"><a href="../howto/"><img src="../../images/arrow-up.gif"
    width="34" height="34" alt="[Up]" border="0"></a></td>
   <td align="right"><a href="new-driver.html"><img src="../../images/arrow-left.gif"
    width="34" height="34" alt="[Prev]" border="0"></a>
    <a href="new-model.html"><img src="../../images/arrow-right.gif"
    width="34" height="34" alt="[Next]" border="0"></a></td></tr>
 </table></td>
 <td>&nbsp;</td>
 <td>&nbsp;</td></tr>

<tr valign="top"><td bgcolor="#ffffdd">
 <!-- Navigation bar. -->
 <table width="100%" border="0" cellspacing="0" cellpadding="1">
  <tr><td class="nav1"><img src="../../images/pad.gif"
    width="10" height="1" hspace="2" alt=" "></td>
   <td class="nav1" colspan="3"><b>Quick Links</b></td></tr>
  <tr><td class="nav2">&nbsp;</td><td class="nav2">&nbsp;&nbsp;</td>
   <td class="nav2" colspan="2"><a href="../../../releases.html">Releases</a></td></tr>
  <tr><td class="nav2">&nbsp;</td><td class="nav2">&nbsp;&nbsp;</td>
   <td class="nav2" colspan="2"><a href="../../main/lxr.html">LXR Index</a></td></tr>
  <tr><td class="nav2">&nbsp;</td><td class="nav2">&nbsp;&nbsp;</td>
   <td class="nav2" colspan="2"><a href="http://isscvs.cern.ch/cgi-bin/viewcvs.cgi/?cvsroot=iguana">CVS</a></td></tr>
  <tr><td class="nav2">&nbsp;</td><td class="nav2">&nbsp;&nbsp;</td>
   <td class="nav2" colspan="2"><a href="../../main/faqs.html">FAQs</a></td></tr>
  <tr><td class="nav2">&nbsp;</td><td class="nav2">&nbsp;&nbsp;</td>
   <td class="nav2" colspan="2"><a href="../../main/problems.html">Problems?</a></td></tr>

  <tr><td class="nav1">&nbsp;</td><td class="nav1" colspan="3"><b><a
   href="../../index.html">IGUANA</a></b></td></tr>

  <tr><td class="nav1">&nbsp;</td><td class="nav1" colspan="3"><b><a
   href="../../install/">Installation</a></b></td></tr>

  <tr><td class="nav1">&nbsp;</td><td class="nav1" colspan="3"><b><a
   href="../../userguide/">User Guide</a></b></td></tr>

  <tr><td class="nav1">&nbsp;</td><td class="nav1" colspan="3"><b><a
   href="../../devguide/">Developer Guide</a></b></td></tr>
  <tr><td class="nav2">&nbsp;</td><td class="nav2">&nbsp;&nbsp;</td>
   <td class="nav2" colspan="2"><a href="../conventions.html">Conventions</a></td></tr>
  <tr><td class="nav2">&nbsp;</td><td class="nav2">&nbsp;&nbsp;</td>
   <td class="nav2" colspan="2"><a href="../deps.html">Dependencies</a></td></tr>
  <tr><td class="nav2">&nbsp;</td><td class="nav2">&nbsp;&nbsp;</td>
   <td class="nav2" colspan="2"><a href="../arch.html">Architecture</a></td></tr>
  <tr><td class="nav2">&nbsp;</td><td class="nav2">&nbsp;&nbsp;</td>
   <td class="nav2" colspan="2"><a href="../howto/">How To...?</a></td></tr>
  <tr><td class="nav3">&nbsp;</td><td class="nav3">&nbsp;&nbsp;</td>
   <td class="nav3">&nbsp;&nbsp;</td>
   <td class="nav3"><a href="build.html">Build</a></td></tr>
  <tr><td class="nav3">&nbsp;</td><td class="nav3">&nbsp;&nbsp;</td>
   <td class="nav3">&nbsp;&nbsp;</td>
   <td class="nav3"><a href="new-package.html">Create a Package</a></td></tr>
  <tr><td class="nav3">&nbsp;</td><td class="nav3">&nbsp;&nbsp;</td>
   <td class="nav3">&nbsp;&nbsp;</td>
   <td class="nav3"><a href="new-plugin.html">Create a Plug-in</a></td></tr>
  <tr><td class="nav3">&nbsp;</td><td class="nav3">&nbsp;&nbsp;</td>
   <td class="nav3">&nbsp;&nbsp;</td>
   <td class="nav3"><a href="new-driver.html">Create a Driver</a></td></tr>
  <tr><td class="nav3s">&nbsp;</td><td class="nav3s">&nbsp;&nbsp;</td>
   <td class="nav3s"><img src="../../images/marker.gif"
    width="10" height="10" hspace="2" alt="&gt;"></td>
   <td class="nav3s">Create a Service</td></tr>
  <tr><td class="nav3">&nbsp;</td><td class="nav3">&nbsp;&nbsp;</td>
   <td class="nav3">&nbsp;&nbsp;</td>
   <td class="nav3"><a href="new-model.html">Create a Model</a></td></tr>
  <tr><td class="nav3">&nbsp;</td><td class="nav3">&nbsp;&nbsp;</td>
   <td class="nav3">&nbsp;&nbsp;</td>
   <td class="nav3"><a href="new-browser.html">Create a Browser</a></td></tr>
  <tr><td class="nav3">&nbsp;</td><td class="nav3">&nbsp;&nbsp;</td>
   <td class="nav3">&nbsp;&nbsp;</td>
   <td class="nav3"><a href="new-representable.html">Create a Representable</a></td></tr>
  <tr><td class="nav3">&nbsp;</td><td class="nav3">&nbsp;&nbsp;</td>
   <td class="nav3">&nbsp;&nbsp;</td>
   <td class="nav3"><a href="new-repmap.html">Create a Rep Mapping</a></td></tr>
  <tr><td class="nav3">&nbsp;</td><td class="nav3">&nbsp;&nbsp;</td>
   <td class="nav3">&nbsp;&nbsp;</td>
   <td class="nav3"><a href="update-config.html">Update Configuration</a></td></tr>
  <tr><td class="nav3">&nbsp;</td><td class="nav3">&nbsp;&nbsp;</td>
   <td class="nav3">&nbsp;&nbsp;</td>
   <td class="nav3"><a href="other-projects.html">Work With Other Projects</a></td></tr>
  <tr><td class="nav3">&nbsp;</td><td class="nav3">&nbsp;&nbsp;</td>
   <td class="nav3">&nbsp;&nbsp;</td>
   <td class="nav3"><a href="release.html">Release IGUANA</a></td></tr>
  <tr><td class="nav3">&nbsp;</td><td class="nav3">&nbsp;&nbsp;</td>
   <td class="nav3">&nbsp;&nbsp;</td>
   <td class="nav3"><a href="debug.html">Debug</a></td></tr>
  <tr><td class="nav3">&nbsp;</td><td class="nav3">&nbsp;&nbsp;</td>
   <td class="nav3">&nbsp;&nbsp;</td>
   <td class="nav3"><a href="webpages.html">Update Web Pages</a></td></tr>
  <tr><td class="nav3">&nbsp;</td><td class="nav3">&nbsp;&nbsp;</td>
   <td class="nav3">&nbsp;&nbsp;</td>
   <td class="nav3"><a href="screenshot.html">Make a Screen Shot</a></td></tr>

  <tr><td class="nav1">&nbsp;</td><td class="nav1" colspan="3"><b><a
   href="../../apiref/">API Reference</a></b></td></tr>

  <tr><td class="nav1">&nbsp;</td><td class="nav1" colspan="3"><b><a
   href="../../info/">More Information</a></b></td></tr>

  <tr><td class="nav1">&nbsp;</td>
   <td class="nav1" colspan="3"><hr noshade="noshade" border="1"></td></tr>
  <tr><td class="nav1">&nbsp;</td><td class="nav1" colspan="3"><form
    method="get" action="http://www.google.com/custom">
    <font face="Helvetica, Arial, Sans-Serif" size="-1">
     <a href="http://www.google.com/search"><img src="../../images/google.gif" border="0"
      alt="Google Search" width="16" height="16"></a>
     <input type="text" name="q" size="11">
     <input type="hidden" name="cof"
     value="LW:98;L:http://iguana.cern.ch/snapshot/images/mini.gif;LH:64;AH:center;S:http://iguana.cern.ch;AWFID:9ebb11a906c88373;">
     <input type="hidden" name="domains" value="iguana.web.cern.ch">
     <input type="hidden" name="sitesearch" value="iguana.web.cern.ch">
     <b><input value="Search" type="submit"></b></font></form>
     <!-- <br><input type="radio" name="sitesearch" value="" checked> Search WWW
      <input type="radio" name="sitesearch" value="iguana.web.cern.ch"> Search IGUANA</font> -->
    </form>
   </td></tr></table>
</td>
<td>&nbsp;</td>

<td width="100%" align="left" valign="top">
 <!-- FIXME: link all this stuff the class docs! -->
 <h3><a name="overview">Overview</a></h3>
 <div class="sect1"><p>IGUANA has application drivers and extensions
   that together form the full application.  <i>Services</i> are
   special kinds of extensions that manage a particular aspect of the
   application state or functionality for their clients.  They usually
   register themselves in the <i>session</i> object.  For more
   details, please refer to the <a href="../arch.html">architectural
   description</a>.</p>

   <p>Services can be created in their own packages, or in existing
   packages as a part of a larger whole.  This guide assumes the
   latter, hence we will not be creating a new package for it.  The
   steps are as follows:</p>
   <ul>
     <li> <a href="#design">Design the service.</a>
     <li> <a href="#define">Define the service class.</a>
     <li> <a href="#implement">Implement the service class.</a>
     <li> <a href="#register">Register the service class (optional).</a>
   </ul>

   <p>This receipe assumes that you are using the IGUANA C++ templates
   (automatically available in our emacs customisation).</p>
 </div>

 <h3><a name="design">Design the service</a></h3>
 <div class="sect1"><p>The first step in developing a new service is
   of course selecting a design for it.  The intended use of the
   service provides significant input to this step.  The answers
   to the following questions will help to draft the design:</p>

   <ul>
     <li> Is the service a means of centralising a bit of code, such
          as providing a point of communication or the management of
	  a resource, or a point of extending the application?

     <li> Are there multiple alternative implementations of the
          service?  Is the choice among the implementations made
	  at compile-time or dynamically at run-time?

     <li> Is the service a means to combine -- as opposed to choose
          among -- a number of concrete implementations?

     <li> How should the service be initialised?  On first use, or
          with a special initialisation context?
   </ul>

   <p>Most services ought to be designed to be objects, not global
   singletons.  A service can be global if and only if it manages
   process-wide resources that cannot meaningfully be restricted to
   the scope of the client -- managers of shared libraries, signal
   handlers and such.  All others should be objects attached with a
   session or other context object.  This implies inheritance from
   <tt>IgExtension</tt>.</p>

   <p>A service should be designed to be used directly via its class
   interface, not as a dynamically loaded extension.  The service can
   of course delegate its internal implementation to dynamically
   loaded components as detailed <a href="#design.ext">below</a>.
   There is however no point making the service itself a dynamically
   loaded extension: the client needs that specific service and the
   simplest way for it to use it is to use the class directly.</p>

   <p>Now consider the questions above.  The most important one is
   whether the service merely centralises the management of a
   resource, communication or some such concept, or is a point of
   application extension.  The examples of the former would be
   services that manage the current selection, current window focus,
   menus, tool bars, how to run GUI event loops, and so forth.  We
   will discuss these simpler designs first.</p>
 </div>

 <h4><a name="define.simple">Simple services</a></h4>
 <div class="sect2"><p> The simple service class design goes roughly as
   follows.  Issues independent of creation are covered in the <a
   href="#define.common">"Common desing patterns" section
   below.</a></p>

   <ul>
     <li> The service class interface should provide the means for the
	  clients to perform the necessary tasks.  That this class
	  will be an IGUANA service extension should not affect this
	  part of the design at all.<p>
     <li> The class should have a static <tt>instance</tt> method that
	  clients use to get access to the service (more on this <a
	  href="#define.common">below</a>).<p>
     <li> The service constructor should be private so that clients
	  use only the <tt>instance</tt> method to access the
	  service.<p>
     <li> The service should not exposed as an extension in the
	  plug-in registry.<p>
   </ul>
 </div>

 <h4><a name="define.dyninst">Services with dynamic selection of
   implementation</a></h4>
 <div class="sect2"><p>This section describes the design of a little a
   bit more complex services: those that have multiple alternative
   and mutually exclusive implementations, of which one is selected at
   run-time.  For these services you will need to provide two things:
   a class hierarchy and a mechanism to select the implementation.</p>

   <p>The class hierarchy defines the abstract base class through
   which the clients will be able to use a number of concrete
   implementations.  The base class should be rich enough that no
   client needs to cast it down to a specific implementation (if that
   seems necessary, the service should probably use a different design
   brake-down as described in the <a href="#define.ext">next
   section</a>).  This is merely ordinary use of abstract classes and
   nothing new.</p>

   <p>The complexity is in how to select the concrete implementation.
   The simplest method is to instantiate an implementation somewhere
   in the code, for example in the driver.  However, this is unlikely
   to work longer term, making it necessary to provide means to make
   the selection dynamically.  We typically do this by the following
   (ab)use of the plug-in database as a registry and factory:</p>

   <ul>
     <li> All concrete service implementations are registered as
	  application extensions in the plug-in database, using a
	  naming convention defined by the base service (typically
	  a naming prefix).  This implies the concrete implementations
	  must be in a plug-in library -- even if all of them are in
	  the same library as the base service itself.<p>

     <li> The base service provides an <tt>instantite</tt> method
	  that selects a particular implementation using the names
	  of the extensions.  It can also provide the list of the
	  names of the available concrete implementations by querying
	  the plug-in database for extensions whose names match the
	  service-specific naming convention.<p>

     <li> The client creates the concrete service instance with the
	  <tt>instance</tt> method by passing it the name of the
	  concrete instance it wants.  The <tt>instance</tt> method
	  uses the naming convention to translate the given name to an
	  extension name, requests the plug-in manager to dynamically
	  load and instantiate the extension by that name, casts the
	  resulting pointer down to the abstract service base
	  interface, and then registers the pointer into the
	  session.<p>

     <li> The client provides the name based on user selection (which
	  can be restricted to the list of available choices provided
	  the base service), from a configuration file, or some aspect
	  of the running environment.  A default choice can be given
	  by using some naming heuristic as well (e.g. one extension
	  can be registered twice, under its own name and as a synonym
	  by a name such as "Default").<p>

     <li> Subsequent uses of the service retrieve the pointer from
	  the session.<p>
   </ul> 

   <p><font color="#888888">[FIXME: The service interface should
   provide all the methods that are relevant to the service.  Some of
   the methods can be virtual and even abstract if there are several
   concrete instances that can be used interchangeably.  In that case
   all participating class should ensure they register the service
   with the same name into the session, and only the base class is
   used in clients to retrieve a pointer to the service
   instance.]</font></p>

   <p><font color="#888888">[FIXME: This approach can be augmented
   with the <tt>IgSession::remap</tt> facility that allows the
   selection of the session instance to be delayed until runtime; in
   this case only the base class has an <tt>instance</tt> method,
   which would use the <tt>IgSession</tt> dynamic extension creation
   mechanism (which is affected by <tt>remap</tt>) to select the
   particular instance to run.  This assumes the concrete instances
   are registered in the plug-in database as extensions, presumably
   with some common naming scheme.]</font></p>

 </div>

 <h4><a name="define.ext">Extensible services</a></h4>
 <div class="sect2"><p>The final category of services are the most
   complex ones: those that are application extension points, usually
   mini-plug-in architectures of their own.  These are services where
   it is not sufficient to merely select among a number of concrete
   service implementations, but one needs to make the service itself
   more modular.  These services need to provide fairly large degree
   of configurability either to clients or other plug-ins in the
   system -- or both.  This is the case in particular if the purpose
   is to allow a number of plug-ins to hook into some feature.</p>

   <p>The service design will depend a little bit on what you will
   want to achieve; we will describe here two scenarios.  The first is
   a service that is a simple <i>extension point</i>.  It has a
   concrete service class that clients will use.  Internally it also
   defines an abstract interface which plug-in extensions specific to
   this service can implement.  Externally, to the clients of the
   service, these plug-ins need not be visible in any way.</p>

   <p>The second scenario is where a service is <i>extensible and
   these extensions must be made visible to the clients.</i>  This
   requires one or more abstract interfaces to be defined for the
   service components -- elements that the service clients will be
   able to use.  The service should be in charge of orchestrating
   these components, and in particular for instantiating them, but
   otherwise the clients should use the abstract interfaces in
   addition to the service interface itself.  In essence this is a
   design much like the IGUANA plug-in architecture itself -- the
   service becomes a task-specific mini-plug-in architecture of its
   own, exploiting the IGUANA plug-in manager as a registry and a
   factory for the internal components.</p>

   <p>In both of the above cases the design steps are something like
   this:</p>
   <ul>
     <li> The service has an <tt>instance</tt> method which the
	  clients use to instantiate the service object into the
	  session (see <a href="#design.common">below</a> for more
	  detailed discussion).  The service itself is typically
	  not created dynamically, but used directly as in the <a
	  href="#define.simple">simplest case</a>.<p>

     <li> The service defines one or more abstract interfaces for
	  the internal components.  The interfaces inherit from
	  <tt>IgExtension</tt> so that they concrete implementations
	  can be registered in the plug-in database.  The service
	  also defines a naming convention, typically a naming prefix,
	  with which extensions are to be registered.  Using this
	  convention it can query the plug-in database for available
	  extension components.  In other words, the service can use
	  the plug-in database as a simple registry.<p>

     <li> Concrete implementations of those abstract component
	  interfaces are implemented and registered as application
	  extension plug-ins, using the service naming convention.<p>

     <li> The service instantiates these components as implementation
	  logic requires: all at once, on client request based on the
	  component name, lazily on demand, and so forth.  In general
	  we encourage the use of lazy loading even though it implies
	  a little more coding.  When creating a component, the
	  service asks the plug-in database to instantiate the
	  extension, casts the resulting pointer down to the service
	  component abstract interface to check that the extension has
	  the proper form, and then uses that pointer internally.
	  This makes use of the plug-in database as a factory.<p>

     <li> Because the service components are created as application
	  extensions, they will only get a session pointer as the
	  constructor argument.  Therefore they should be designed to
	  do little or nothing in the constructor and instead define
	  separate virtual method to <tt>bind</tt> the extension with
	  the service object.  (Similarly for a <tt>release</tt>
	  method if the service will dynamically adjust which
	  components it uses.)  The service should invoke the bind
	  method immediately after creating the component and having
	  cast the pointer down from <tt>IgExtension</tt> to the
	  service-specific class interface.<p>
   </ul>

   <p><font color="#888888">[FIXME: The final method, dynamic service
   extension is the least clumsy service method and our preferred
   mechanism for delegating the selection of service implementation
   until runtime.  It is also the method to use in services that
   should automatically extend to new functionality based on
   capabilities available in the system.  In this method the base
   service is a concrete object that delegates parts of its
   functionality to one or more surrogate objects.  The surrogates are
   dynamically loaded extensions; the choice of which extensions to
   load is usually based on the user's choices, or the service may
   load all of them, or the choice can determined by some
   configuration setting in the environment.  The base service usually
   defines one or more interfaces to which concrete extensions must
   conform, as well as a naming convention with which the extensions
   conforming to the service's interface register into the plug-in
   database.  That is, the plug-in database is used as a registry of
   available functionality, and the service instantiates extensions
   from that registry and downcasts the resulting <tt>IgExtension</tt>
   pointers to its own interfaces.  The service is in essence designed
   as a little mini-plug-in architecture of its own.]</font></p>

   <p><font color="#888888">[FIXME: Explain how to attach
   component-specific gui wizards or configurators for services that
   are themselves not intrinsically gui-related but need some
   configuration.]</font></p>
 </div>

 <h4><a name="define.common">Common design patterns</a></h4>
 <div class="sect2"><p>In general, all services should be created
   via a class-static <tt>instance</tt> method.  This method can
   create a global object, instantiate the object into the session,
   select an alternative implementation from the plug-in database,
   and so forth as discussed above.  There can be either just one
   <tt>instance</tt> method that is used to both retrieve an existing
   service object and to create the instance, or two separate methods,
   one for retrieving and for initial construction.</p>

   <p>The most significant issue in selecting how many and what kinds
   of <tt>instance</tt> methods to provide depends on the amount of
   context required to create the service.  Services that need no
   additional context in constructor and which can be simply created
   on first use should certainly have just a single <tt>instance</tt>
   method.  It should look up the service in the session, and if not
   found, create it, and then return a pointer to the service to the
   client.  Except for global services, the methods should take as an
   argument a pointer to the session object.</p>

   <p>If the service needs non-trivial constructor arguments, you
   should add another <tt>instance</tt> method that takes those
   arguments, creates the service, registers it with the session, and
   then returns the pointer to the caller.  The reason for doing it
   this way instead of creating the service object directly with the
   <tt>new</tt> operator is to gain uniform coding pattern for all
   services, both those that are created dynamically or indirectly and
   those that are created directly.  (Besides, it makes it possible to
   later change the design.)  At any rate, it must be made clear who
   must create the service and when.  Typically this will become the
   duty of the application driver or some higher-level service.  The
   clients that just want to use of the service should <i>never</i> be
   required to be smart enough to create the service as well as using
   it -- this will just end up pushing lots of irrelevant high-level
   knowledge to very deep levels in the application.</p>

   <p>Instead of having two separate <tt>instance</tt> methods, it is
   possible to combine the two if the extra constructor arguments can
   be given default arguments such as null pointers.  However as this
   is somewhat confusing as to how it should be invoked, we recommend
   using two separate methods even though it is a little bit more
   coding.</p>

   <p><font color="#888888">[FIXME: inter-service dependencies]</font></p>
 </div>

 <h3><a name="define">Define the service class</a></h3>
 <div class="sect1"><p>Let as assume that your service will be called
   <tt>IgFooService</tt>.  Create <tt>interface/IgFooService.h</tt> in
   which you declare class <tt>IgFooService</tt>.  Opening a new file
   with that name in emacs will automatically insert the header file
   and basic class structure if you are using our C++ customisation
   layer.</p>

   <p>Following the advice from above and designing the most basic
   type of service, the class should look like as follows.</p>

   <pre>#ifndef IG_FOO_BAR_IG_FOO_SERVICE_H
# define IG_FOO_BAR_IG_FOO_SERVICE_H

//&lt;&lt;&lt;&lt;&lt;&lt; INCLUDES                                   &gt;&gt;&gt;&gt;&gt;&gt;

# include "Ig_Modules/IgFooBar/interface/config.h"
# include "Ig_Framework/IgObjectBrowser/interface/IgExtension.h"

//&lt;&lt;&lt;&lt;&lt;&lt; PUBLIC DEFINES                             &gt;&gt;&gt;&gt;&gt;&gt;
//&lt;&lt;&lt;&lt;&lt;&lt; PUBLIC CONSTANTS                           &gt;&gt;&gt;&gt;&gt;&gt;
//&lt;&lt;&lt;&lt;&lt;&lt; PUBLIC TYPES                               &gt;&gt;&gt;&gt;&gt;&gt;

class IgSession;

//&lt;&lt;&lt;&lt;&lt;&lt; PUBLIC VARIABLES                           &gt;&gt;&gt;&gt;&gt;&gt;
//&lt;&lt;&lt;&lt;&lt;&lt; PUBLIC FUNCTIONS                           &gt;&gt;&gt;&gt;&gt;&gt;
//&lt;&lt;&lt;&lt;&lt;&lt; CLASS DECLARATIONS                         &gt;&gt;&gt;&gt;&gt;&gt;

class IG_FOO_BAR_API IgFooService : public IgExtension
{
public:
    IgFooService *	instance (IgSession *session);

    // other service methods here

protected:
    IgFooService (IgSession *session);
    // implicit copy constructor
    // implicit assignment operator
    // implicit destructor

private:
    IgSession		*m_session;
};

//&lt;&lt;&lt;&lt;&lt;&lt; INLINE PUBLIC FUNCTIONS                    &gt;&gt;&gt;&gt;&gt;&gt;
//&lt;&lt;&lt;&lt;&lt;&lt; INLINE MEMBER FUNCTIONS                    &gt;&gt;&gt;&gt;&gt;&gt;

#endif // IG_FOO_BAR_IG_FOO_SERVICE_H</pre>
 </div>

 <h3><a name="implement">Implement the service class</a></h3>
 <div class="sect1"><p>Now create <tt>src/IgFooService.cc</tt> to
   implement the service.  Opening a new file with that name in
   emacs will automatically insert the basic structure if you are
   using our C++ customisation layer.  Define the methods as shown
   below.</p>

   <pre>//&lt;&lt;&lt;&lt;&lt;&lt; INCLUDES                                   &gt;&gt;&gt;&gt;&gt;&gt;

#include "Ig_Modules/IgFooBar/interface/IgFooService.h"
#include &lt;classlib/debug.h&gt;

//&lt;&lt;&lt;&lt;&lt;&lt; PRIVATE DEFINES                            &gt;&gt;&gt;&gt;&gt;&gt;
//&lt;&lt;&lt;&lt;&lt;&lt; PRIVATE CONSTANTS                          &gt;&gt;&gt;&gt;&gt;&gt;
//&lt;&lt;&lt;&lt;&lt;&lt; PRIVATE TYPES                              &gt;&gt;&gt;&gt;&gt;&gt;
//&lt;&lt;&lt;&lt;&lt;&lt; PRIVATE VARIABLE DEFINITIONS               &gt;&gt;&gt;&gt;&gt;&gt;
//&lt;&lt;&lt;&lt;&lt;&lt; PUBLIC VARIABLE DEFINITIONS                &gt;&gt;&gt;&gt;&gt;&gt;
//&lt;&lt;&lt;&lt;&lt;&lt; CLASS STRUCTURE INITIALIZATION             &gt;&gt;&gt;&gt;&gt;&gt;
//&lt;&lt;&lt;&lt;&lt;&lt; PRIVATE FUNCTION DEFINITIONS               &gt;&gt;&gt;&gt;&gt;&gt;
//&lt;&lt;&lt;&lt;&lt;&lt; PUBLIC FUNCTION DEFINITIONS                &gt;&gt;&gt;&gt;&gt;&gt;
//&lt;&lt;&lt;&lt;&lt;&lt; MEMBER FUNCTION DEFINITIONS                &gt;&gt;&gt;&gt;&gt;&gt;

IgFooService *
IgFooService::instance (IgSession *session)
{
    ASSERT (session);
    
    IgFooService	*manager = 0;
    IgExtension		*ext;
    
    if ((ext = session->getExtension ("Runtime/Services/Foo", false)))
        VERIFY (manager = dynamic_cast&lt;IgFooService *&gt; (ext));
    else
    {
        manager = new IgFooService (session);
        session->setExtension ("Runtime/Services/Foo", manager);
    }
    return manager;
}

IgFooService::IgFooService (IgSession *session)
    : m_session (session)
{ ASSERT (m_session); }

IgFooService::~IgFooService (void)
{
    ASSERT (m_session);
    ASSERT (this == m_session->getExtension
            ("Runtime/Services/Foo", false));
    m_session->setExtension ("Runtime/Services/Foo", 0);
}

// other methods here</pre>
 </div>

 <h3><a name="register">Register the service class (optional)</a></h3>
 <div class="sect1"><p>If you are following one of the more complex
   scenarios described above, you will need to register the service
   or a component of it in the plug-in database as an application
   extension.  Follow the instructions in <a
   href="new-plugin.html#check">plug-in creation</a> guide.  Then
   check that the extensions show up when you list the plug-in cache
   contents with <tt>iguana</tt>, like this:</p>
   <pre>$ eval `scram runtime -sh`
$ iguana --list</pre>

   <p>If these extensions are only for internal service use and are
   not supposed to be used directly by the users, please document
   that fact.  Also choose a naming convention from which it is clear
   that the components are for internal implementation, not public
   GUI components for instance.  (IGUANA applications will soon be
   able to let users request additional plug-ins to be loaded at
   run-time.  The only information we have is the plug-in names.)</p>
 </div>
</td></tr>

<tr>
 <td bgcolor="#ffffdd"><table border="0" width="100%"><tr>
   <td align="left"><a href="mailto:iguana-developers@cern.ch"><img
    src="../../images/mailto.gif" border="0" width="14" height="10"
    alt="[Mail]"></a></td>
   <td align="right"><font face="Arial, Helvetica"
    size="-2">$Date: 2006/09/11 07:45:25 $</font></td></tr></table></td>
 <td><font face="Arial, Helvetica" size="-2">&nbsp;</font></td>
 <td><font face="Arial, Helvetica" size="-2">&nbsp;</font></td></tr>
</table>
</body>
</html>
