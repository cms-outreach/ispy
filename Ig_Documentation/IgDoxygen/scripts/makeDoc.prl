#!/usr/bin/env perl
#
# Perl script to make documentation.
#
# Called from:
#
#    1:   IGUANA_doc.mk                   (when using "scam build doc" command)
#    2:   /afs/cern.ch/cms/adm/IGUANAdoc  (to build snapshots doc)
#
# Basename of source files to be processed:
#

use File::Find;

$_ = "@ARGV";

#############################################################################
# Main:
#############################################################################
(&print_usage () && die) if $#ARGV != 5;

$project             = @ARGV[0];
$project_version     = @ARGV[1];
$last_version        = @ARGV[2];
$local_top           = @ARGV[3];
$project_html_dir    = @ARGV[4];
$project_out_dir     = @ARGV[5];

$project_versnum     = $last_version;
$project_versnum     =~ s/^[^_]+_//;
$project_versnum     =~ y/_/./;

%substs		     = ('@VERSION@' => $project_version,
			'@LAST_VERSION@' => $last_version,
			'@VERSNUM@' => $project_versnum);

if ( -e "$local_top/src" ) {
  # this is what you have for a SCRAM checkout area (e.g. when
  # making a release)
  $project_in_dir    = "$local_top/src";
} else {
  # this is what we (used to?) have for the snapshot version (CVS
  # checkout area) would be nice to make snapshot similar to proper
  # release one day
  $project_in_dir    = "$local_top";
}

$project_out_dir_tmp = "$project_out_dir/mydoc";

-e $project_out_dir || mkdir ($project_out_dir,0755) || die;
-e $project_out_dir_tmp || mkdir ($project_out_dir_tmp,0755) || die;
-e "$project_out_dir/doc" || mkdir ("$project_out_dir/doc",0755) || die;
-e "$project_out_dir/doc/apiref" || mkdir ("$project_out_dir/doc/apiref",0755) || die;

print "***********************************************\n";
print "                                               \n";
print "  project               = $project             \n";
print "  project_version       = $project_version     \n";
print "  local_top             = $local_top           \n";
print "  project_html_dir      = $project_html_dir    \n";
print "                        =                      \n";
print "  project_in_dir        = $project_in_dir      \n";
print "  project_out_dir       = $project_out_dir     \n";
print "  project_out_dir_tmp   = $project_out_dir_tmp \n";
print "                                               \n";
print "***********************************************\n";

# Create a file for repository structure description.
open( NEW, ">$project_out_dir_tmp/repository.html" )
    || die "Can't create file $project_out_dir_tmp/repository.html";
&process_dir( $project_in_dir );
close NEW;

&create_inifile("repository", "Structure of the $project Project");
&make_doc_file("repository.ini", "repository.doc",
	       "$project_out_dir_tmp/repository.html");

# Run doxygen; generate first a banner for its use
&split_file("$project_html_dir/apiref/page.html",
            "$project_out_dir_tmp/apibanner.html",
	    "$project_out_dir_tmp/apitrailer.html",
	    %substs, '@DOCDIR@' => '../');
&create_doxyfile();
$| = 1; $| = 0;
system "cd $project_out_dir; doxygen; rm Doxyfile";
$| = 1; $| = 0;

# Copy the web.
map { &process_file ("$project_html_dir/weblayout.css",
		     "$project_out_dir/doc/$_/weblayout.css",
		     %substs, '@DOCDIR@' => &dirrel($_)) }
qw(apiref devguide devguide/howto info info/meetings info/papers
   info/presentations install main userguide);

&find ({ wanted => sub {
  /\.html$/ || return;
  $file = $File::Find::name; $subpart = $file; $subpart =~ s|^$project_html_dir/||;
  &process_file ("$file", "$project_out_dir/doc/$subpart",
		 %substs, '@DOCDIR@' => &dirrel($subpart)); } },
  $project_html_dir);

&find ({ wanted => sub {
  /\.(gif|jpg|css|ps|eps|pdf)$/ || return;
  $file = $File::Find::name; $subpart = $file; $subpart =~ s|^$project_html_dir/||;
  &copy_file ("$file", "$project_out_dir/doc/$subpart"); } },
  $project_html_dir);

# Get rid of the temporary directory
system "rm -fr $project_out_dir_tmp";
print "done.\n";

#############################################################################
# Subroutines:
#############################################################################

sub print_usage {
    print "*************************************************************************\n";
    print "                                                                         \n";
    print "The script will create doc files in Doxygen format                       \n";
    print "and make a repository structure page.                                    \n";
    print "                                                                         \n";
    print "  Usage:                                                                 \n";
    print "                                                                         \n";
    print "    perl makeDoc.prl project project_version last_version local_top project_html_dir project_out_dir \n";
    print "                                                                         \n";
    print "  project               = project name                                   \n";
    print "  project_version       = project version                                \n";
    print "  last_version          = last real project version                      \n";
    print "  local_top             = top-level directory of release / checkout area \n";
    print "  project_html_dir      = directory containing documentation             \n";
    print "  project_out_dir       = output documentation directory                 \n";
    print "                                                                         \n";
    print "*************************************************************************\n";
}

sub dirrel {
    my $file = shift;
    $file =~ s|[^/]*$||;
    $file =~ s|[^/]*/|../|g;
    return $file;
}

sub dirof {
    my $file = shift;
    $file =~ s|[^/]*$||;
    $file =~ s|/$||;
    return $file;
}

sub split_file {
    # Split $in to $banner and $trailer at line "<!-- SPLIT -->",
    # making substitutions %subst as we go.
    use File::Path;

    my ($in, $banner, $trailer, %substs) = @_;
    my ($k, $v);
    local $_;

    print "### processing: $in\n";
    -d &dirof($banner) || &mkpath(&dirof ($banner)) || die;
    -d &dirof($trailer) || &mkpath(&dirof ($trailer)) || die;

    open(TEMPLATE, "< $in") || die;
    open(OUTBANNER, "> $banner") || die;
    open(OUTTRAILER, "> $trailer") || die;
    my $inbanner = 1;
    while (<TEMPLATE>) {
      if ($inbanner && /<!-- SPLIT -->/) {
        $inbanner = 0;
        next;
      }
      while (($k, $v) = each %substs) { s/$k/$v/g; }
      if ($inbanner) {
        print OUTBANNER;
      } else {
        print OUTTRAILER;
      }
    }
    close TEMPLATE;
    close OUTBANNER;
    close OUTTRAILER;
}

sub process_file {
    # Copy $srcfile to $destfile, making %substs substitutions as we go.
    use File::Path;
    my ($srcfile, $destfile, %substs) = @_;
    my $saved;
    local $_;

    print "### processing: $srcfile\n";

    -d &dirof($destfile) || &mkpath(&dirof ($destfile)) || die;

    # Open source file for reading and target file for writing:
    open( SRC, $srcfile )	|| die "Can't open file $srcfile: $!\n";
    open( DEST, "> $destfile" ) || die "Can't create file $destfile: $!\n";

    # Get HTML header and non-content lines that follow it (looks for
    # a body line, discards it and any following lines where the first
    # non-space character is not a `<')
    while (<SRC>) {
      while (($k, $v) = each %substs) { s/$k/$v/g; };
      print DEST
    }
    close DEST;
    close SRC;
}

sub copy_file {
   # Copy $srcfile to $destfile, preserving timestamps etc. if possible.
   use File::Path;
   my ($srcfile, $destfile) = @_;

   print "### copying: $srcfile\n";
   -d &dirof ($destfile) || &mkpath(&dirof ($destfile)) || die;
   system "cp -p $srcfile $destfile" || die;
}

sub create_inifile {
    my ($ini_file, $title) = @_;
    $title ||= $ini_file;

    (open (INI, ">$project_out_dir_tmp/$ini_file.ini")
     && print (INI "/** \\page $ini_file $title\n \\htmlonly\n\n\n \\endhtmlonly\n\n*/\n")
     && close INI)
	|| die( "Can't create file $project_out_dir_tmp/$ini_file.ini" );
}

sub make_doc_file {
    # Create .doc file and include index.html inside
    my ($src_file, $des_file, $index_file) = @_;

    # Open source file for reading and target file for writing:
    open( DOCSRC, "$project_out_dir_tmp/$src_file" )
        || die( "Can't open file $project_out_dir_tmp/$src_file" );
    open( DOCDES, ">$project_out_dir_tmp/$des_file" )
        || die( "Can't create file $project_out_dir_tmp/$des_file" );

    # Keep 1st line and 2nd line in header files (\page, \htmlonly):
    $_ = <DOCSRC>; print DOCDES; # Keep 1st line.
    $_ = <DOCSRC>; print DOCDES; # Keep 2nd line.

    if ( -e "$index_file" ) {
        # Read html file and insert it in .doc.new:
        open( HTML, "$index_file" ) || return;
        print DOCDES <HTML>;
        close HTML;
    }

    # insert in .doc.new the rest from .doc:
    print DOCDES <DOCSRC>;

    close DOCSRC;
    close DOCDES;
}

sub process_dir {
    # Scan src dir and create .doc files
    my ($target_dir) = @_;

    print "### process_dir: $target_dir\n";
    opendir( DIR, "$target_dir") || die( "Can't find dir $target_dir" );
    @dirs = readdir( DIR );
    closedir( DIR );

    foreach $d (@dirs) {
	next if ! -d "$target_dir/$d" ||
	    grep ($d eq $_, qw(. .. CVS workspace Workspace doc domain
			       Porting BuildFile .admin), $project);

	print "$d\n";
	&create_inifile($d);
	print NEW "\n\n \\endhtmlonly \\ref $d \\htmlonly\n <ul>\n";
	&process_subdir ("$target_dir/$d");
	print NEW "</ul>\n";

	next if $d eq $project || -e "$target_dir/$d/domain/doc/$d.doc";
	&make_doc_file ("$d.ini", "$d.doc", "$target_dir/$d/domain/doc/html/index.html");
    }
}

sub process_subdir {
    # Scan subdirs and create .doc files (don't go deeper)
    my ($target_subdir) = @_;

    opendir( DIR, "$target_subdir") || die( "Can't find dir $target_dir" );
    @subdirs = readdir( DIR );
    closedir( DIR );

    foreach $d (@subdirs) {
	next if ! -d "$target_subdir/$d"
	    || grep ($d eq $_, qw(. .. CVS doc domain BuildFile .admin));

	print "    |- $d\n";
	print NEW "<li> \\endhtmlonly \\ref $d \\htmlonly\n";
	&create_inifile($d);

	next if -e "$target_subdir/$d/doc/$d.doc";
	&make_doc_file ("$d.ini", "$d.doc", "$target_subdir/$d/doc/html/index.html");
    }
}

sub create_doxyfile {
    print "### create_doxyfile\n";

    # Open source file for writing:
    open( DOX_FD, ">$project_out_dir/Doxyfile" )
	|| die "Can't create file $project_out_dir/Doxyfile";

    #---------------------------------------------------------------------------
    # General configuration options
    #---------------------------------------------------------------------------

    # The PROJECT_NAME tag is a single word (or a sequence of word
    # surrounded by quotes) that should identify the project.

    print DOX_FD "PROJECT_NAME         = $project\n";

    # The PROJECT_NUMBER tag can be used to enter a project or
    # revision number.  This could be handy for archiving the
    # generated documentation or if some version control system is
    # used.

    print DOX_FD "PROJECT_NUMBER       = $project_version\n";

    # The OUTPUT_DIRECTORY tag is used to specify the (relative or
    # absolute) base path where the generated documentation will
    # be put.  If a relative path is entered, it will be relative
    # to the location where doxygen was started. If left blank the
    # current directory will be used.

    print DOX_FD "OUTPUT_DIRECTORY     =\n";

    # The OUTPUT_LANGUAGE tag is used to specify the language in
    # which all documentation generated by doxygen is
    # written. Doxygen will use this information to generate all
    # constant output in the proper language.  The default
    # language is English, other supported languages are: Dutch,
    # French, Italian, Czech, Swedish, German and Japanese

    print DOX_FD "OUTPUT_LANGUAGE      = English\n";

    # The DISABLE_INDEX tag can be used to turn on/off the
    # condensed index at top of each HTML page. The value NO (the
    # default) enables the index and the value YES disables it.

    # I turn this OFF and do it myself in a nicer format in
    # banner.html (L.Taylor, 4 May 2000)

    print DOX_FD "DISABLE_INDEX        = YES\n";

    # If the EXTRACT_ALL tag is set to YES all classes and
    # functions will be included in the documentation, even if no
    # documentation was available.

    print DOX_FD "EXTRACT_ALL          = YES\n";

    # If the EXTRACT_PRIVATE tag is set to YES all private members
    # of a class will be included in the documentation.

    print DOX_FD "EXTRACT_PRIVATE      = YES\n";

    # If the EXTRACT_STATIC tag is set to YES all static members of a file
    # will be included in the documentation.

    print DOX_FD "EXTRACT_STATIC        = YES\n";


    # If the HIDE_UNDOC_MEMBERS tag is set to YES, Doxygen will
    # hide all undocumented members inside documented classes or
    # files.

    print DOX_FD "HIDE_UNDOC_MEMBERS   = NO\n";

    # If the HIDE_UNDOC_CLASSESS tag is set to YES, Doxygen will
    # hide all undocumented classes.

    print DOX_FD "HIDE_UNDOC_CLASSES   = NO\n";

    # If the BRIEF_MEMBER_DESC tag is set to YES (the default)
    # Doxygen will include brief member descriptions after the
    # members that are listed in the file and class documentation
    # (similar to JavaDoc).  Set to NO to disable this.

    print DOX_FD "BRIEF_MEMBER_DESC    = YES\n";

    # The INTERNAL_DOCS tag determines if documentation that is
    # typed after a \internal command is included. If the tag is
    # set to NO (the default) then the documentation will be
    # excluded.  Set it to YES to include the internal
    # documentation.

    print DOX_FD "INTERNAL_DOCS        = YES\n";

    # If the REPEAT_BRIEF tag is set to YES (the default) Doxygen
    # will prepend the brief description of a member or function
    # before the detailed description.  Note: if both
    # HIDE_UNDOC_MEMBERS and BRIEF_MEMBER_DESC are set to NO, the
    # brief descriptions will be completely suppressed.

    print DOX_FD "REPEAT_BRIEF         = YES\n";

    # If the ALWAYS_DETAILED_SEC and REPEAT_BRIEF tags are both set to YES then
    # Doxygen will generate a detailed section even if there is only a brief
    # description.

    print DOX_FD "ALWAYS_DETAILED_SEC   = YES\n";


    # If the FULL_PATH_NAMES tag is set to YES Doxygen will
    # prepend the full path before files name in the file list and
    # in the header files. If set to NO the shortest path that
    # makes the file name unique will be used.

    print DOX_FD "FULL_PATH_NAMES      = YES\n";

    # If the FULL_PATH_NAMES tag is set to YES then the
    # STRIP_FROM_PATH tag can be used to strip a user defined part
    # of the path. Stripping is only done if one of the specified
    # strings matches the left-hand part of the path.

    print DOX_FD "STRIP_FROM_PATH      = ./\n";

    # If the CLASS_DIAGRAMS tag is set to YES (the default)
    # Doxygen will generate a class diagram (in Html and LaTeX)
    # for classes with base or super classes. Setting the tag to
    # NO turns the diagrams off.

    print DOX_FD "CLASS_DIAGRAMS       = YES\n";

    # If the SOURCE_BROWSER tag is set to YES than the body of a
    # member or function will be appended as a block of code to
    # the documentation of.  that member or function.

    print DOX_FD "SOURCE_BROWSER       = NO\n";

    # Setting the INLINE_SOURCES tag to YES will include the body
    # of functions and classes directly in the documentation.

    print DOX_FD "INLINE_SOURCES        = NO\n";

    # Setting the STRIP_CODE_COMMENTS tag to YES (the default) will instruct
    # doxygen to hide any special comment blocks from generated source code
    # fragments. Normal C and C++ comments will always remain visible.

    print DOX_FD "STRIP_CODE_COMMENTS   = NO\n";


    # If the CASE_SENSE_NAMES tag is set to NO (the default) then
    # Doxygen will only generate file names in lower case
    # letters. If set to YES upper case letters are also
    # allowed. This is useful if you have classes or files whose
    # names only differ in case and if your file system supports
    # case sensitive file names.

    print DOX_FD "CASE_SENSE_NAMES     = YES\n";

    # If the HIDE_SCOPE_NAMES tag is set to NO (the default) then Doxygen
    # will show members with their full class and namespace scopes in the
    # documentation. If set to YES the scope will be hidden.

    print DOX_FD "HIDE_SCOPE_NAMES      = NO\n";

    # If the VERBATIM_HEADERS tag is set to YES (the default) then
    # Doxygen will generate a verbatim copy of the header file for
    # each class for which an include is specified. Set to NO to
    # disable this.

    print DOX_FD "VERBATIM_HEADERS     = NO\n";

    # If the SHOW_INCLUDE_FILES tag is set to YES (the default) then Doxygen
    # will put list of the files that are included by a file in the documentation
    # of that file.

    print DOX_FD "SHOW_INCLUDE_FILES    = YES\n";

    # If the JAVADOC_NO_AUTOBRIEF is set to YES (the default) then
    # Doxygen will interpret the first line (until the first dot)
    # of a JavaDoc-style comment as the brief description. If set
    # to NO, the Javadoc-style will behave just like the Qt-style
    # comments.

    print DOX_FD "JAVADOC_AUTOBRIEF    = YES\n";

    # If the INHERIT_DOCS tag is set to YES (the default) then an undocumented
    # member inherits the documentation from any documented member that it
    # reimplements.

    print DOX_FD "INHERIT_DOCS          = YES\n";

    # If the INLINE_INFO tag is set to YES (the default) then a tag [inline]
    # is inserted in the documentation for inline members.

    print DOX_FD "INLINE_INFO           = YES\n";

    # If the SORT_MEMBER_DOCS tag is set to YES (the default) then doxygen
    # will sort the (detailed) documentation of file and class members
    # alphabetically by member name. If set to NO the members will appear in
    # declaration order.

    print DOX_FD "SORT_MEMBER_DOCS      = YES\n";

    # The TAB_SIZE tag can be used to set the number of spaces in a tab.
    # Doxygen uses this value to replace tabs by spaces in code fragments.

    print DOX_FD "TAB_SIZE              = 8\n";

    # The ENABLE_SECTIONS tag can be used to enable conditional
    # documentation sections, marked by \if sectionname ... \endif.

    print DOX_FD "ENABLED_SECTIONS      = \n";

    #---------------------------------------------------------------------------
    # configuration options related to warning and progress messages
    #---------------------------------------------------------------------------

    # The QUIET tag can be used to turn on/off the messages that are generated
    # by doxygen. Possible values are YES and NO. If left blank NO is used.

    print DOX_FD "QUIET                 = NO\n";

    # The WARNINGS tag can be used to turn on/off the warning messages that are
    # generated by doxygen. Possible values are YES and NO. If left blank
    # NO is used.

    print DOX_FD "WARNINGS              = YES\n";

    # If WARN_IF_UNDOCUMENTED is set to YES, then doxygen will generate warnings
    # for undocumented members. If EXTRACT_ALL is set to YES then this flag will
    # automatically be disabled.

    print DOX_FD "WARN_IF_UNDOCUMENTED  = YES\n";

    # The WARN_FORMAT tag determines the format of the warning messages that
    # doxygen can produce. The string should contain the $file, $line, and $text
    # tags, which will be replaced by the file and line number from which the
    # warning originated and the warning text.

    print DOX_FD "WARN_FORMAT           = \n";

    #---------------------------------------------------------------------------
    # configuration options related to the input files
    #---------------------------------------------------------------------------

    # The INPUT tag can be used to specify the files and/or
    # directories that contain documented source files. You may
    # enter file names like "myfile.cpp" or directories like
    # "/usr/src/myproject". Separate the files or directories with
    # spaces.

    print DOX_FD "INPUT                = $project_in_dir $project_out_dir_tmp\n";

    # If the value of the INPUT tag contains directories, you can
    # use the FILE_PATTERNS tag to specify one or more wildcard
    # pattern (like *.cpp and *.h) to filter out the source-files
    # in the directories. If left blank all files are included.

    print DOX_FD "FILE_PATTERNS        = *.doc *.h *.icc *.cxx *.cpp *.cc\n";

    # The RECURSIVE tag can be used to turn specify whether or not
    # subdirectories should be searched for input files as
    # well. Possible values are YES and NO.  If left blank NO is
    # used.

    print DOX_FD "RECURSIVE            = YES\n";

    # The EXCLUDE tag can be used to specify files and/or
    # directories that should excluded from the INPUT source
    # files. This way you can easily exclude a subdirectory from a
    # directory tree whose root is specified with the INPUT tag.

    print DOX_FD "EXCLUDE              = \n";

    # If the value of the INPUT tag contains directories, you can
    # use the EXCLUDE_PATTERNS tag to specify one or more wildcard
    # patterns to exclude certain files from those directories.

    print DOX_FD "EXCLUDE_PATTERNS     = */test/*\n";

    # The EXAMPLE_PATH tag can be used to specify one or more
    # files or directories that contain example code fragments
    # that are included (see the \include command).

    print DOX_FD "EXAMPLE_PATH         = ./\n";

    # The INPUT_FILTER tag can be used to specify a program that
    # doxygen should invoke to filter for each input file. Doxygen
    # will invoke the filter program by executing (via popen())
    # the command <filter> <input-file>, where <filter> is the
    # value of the INPUT_FILTER tag, and <input-file> is the name
    # of an input file. Doxygen will then use the output that the
    # filter program writes to standard output.

    print DOX_FD "INPUT_FILTER         =\n";

    #---------------------------------------------------------------------------
    # configuration options related to the alphabetical class index
    #---------------------------------------------------------------------------

    # If the ALPHABETICAL_INDEX tag is set to YES, an alphabetical index
    # of all compounds will be generated. Enable this if the project
    # contains a lot of classes, structs, unions or interfaces.

    print DOX_FD "ALPHABETICAL_INDEX    = YES\n";

    # If the alphabetical index is enabled (see ALPHABETICAL_INDEX) then
    # the COLS_IN_ALPHA_INDEX tag can be used to specify the number of columns
    # in which this list will be split (can be a number in the range [1..20])

    print DOX_FD "COLS_IN_ALPHA_INDEX   = 3\n";

    # In case all classes in a project start with a common prefix, all
    # classes will be put under the same header in the alphabetical index.
    # The IGNORE_PREFIX tag can be used to specify one or more prefixes that
    # should be ignored while generating the index headers.

    print DOX_FD "IGNORE_PREFIX         = \n";

    #---------------------------------------------------------------------------
    # configuration options related to the HTML output
    #---------------------------------------------------------------------------

    # If the GENERATE_HTML tag is set to YES (the default) Doxygen
    # will generate HTML output

    print DOX_FD "GENERATE_HTML        = YES\n";

    # The HTML_OUTPUT tag is used to specify where the HTML docs
    # will be put.  If a relative path is entered the value of
    # OUTPUT_DIRECTORY will be put in front of it. If left blank
    # `html' will be used as the default path.

    print DOX_FD "HTML_OUTPUT          = doc/apiref\n";

    # The HTML_HEADER tag can be used to specify a personal HTML
    # header for each generated HTML page. If it is left blank
    # doxygen will generate a standard header.

    print DOX_FD "HTML_HEADER          = $project_out_dir_tmp/apibanner.html\n";

    # The HTML_FOOTER tag can be used to specify a personal HTML
    # footer for each generated HTML page. If it is left blank
    # doxygen will generate a standard footer.

    print DOX_FD "HTML_FOOTER          = $project_out_dir_tmp/apitrailer.html\n";

    # The HTML_STYLESHEET tag can be used to specify a user defined cascading
    # style sheet that is used by each HTML page. It can be used to
    # fine-tune the look of the HTML output. If the tag is left blank doxygen
    # will generate a default style sheet

    print DOX_FD "HTML_STYLESHEET       = \n";

    # If the HTML_ALIGN_MEMBERS tag is set to YES, the members of
    # classes, files or namespaces will be aligned in HTML using
    # tables. If set to NO a bullet list will be used.

    print DOX_FD "HTML_ALIGN_MEMBERS   = YES\n";

    # If the GENERATE_HTMLHELP tag is set to YES, additional index
    # files will be generated that can be used as input for tools
    # like the Microsoft HTML help workshop to generate a
    # compressed HTML help file (.chm) of the generated HTML
    # documentation.

    print DOX_FD "GENERATE_HTMLHELP    = NO\n";

    #---------------------------------------------------------------------------
    # configuration options related to the LaTeX output
    #---------------------------------------------------------------------------

    # If the GENERATE_LATEX tag is set to YES (the default)
    # Doxygen will generate Latex output.

    print DOX_FD "GENERATE_LATEX       = NO\n";

    # The LATEX_OUTPUT tag is used to specify where the LaTeX docs
    # will be put.  If a relative path is entered the value of
    # OUTPUT_DIRECTORY will be put in front of it. If left blank
    # `latex' will be used as the default path.

    print DOX_FD "LATEX_OUTPUT         =\n";

    # If the COMPACT_LATEX tag is set to YES Doxygen generates
    # more compact LaTeX documents. This may be useful for small
    # projects and may help to save some trees in general.

    print DOX_FD "COMPACT_LATEX        = NO\n";

    # The PAPER_TYPE tag can be used to set the paper type that is
    # used by the printer. Possible values are: a4, a4wide,
    # letter, legal and executive. If left blank a4wide will be
    # used.

    print DOX_FD "PAPER_TYPE           = a4wide\n";

    # The EXTRA_PACKAGES tag can be to specify one or more names
    # of LaTeX packages that should be included in the LaTeX
    # output.

    print DOX_FD "EXTRA_PACKAGES       =\n";

    # The LATEX_HEADER tag can be used to specify a personal LaTeX header for
    # the generated latex document. The header should contain everything until
    # the first chapter. If it is left blank doxygen will generate a
    # standard header. Notice: only use this tag if you know what you are doing!

    print DOX_FD "LATEX_HEADER          = \n";

    # If the PDF_HYPERLINKS tag is set to YES, the LaTeX that is generated
    # is prepared for conversion to pdf (using ps2pdf). The pdf file will
    # contain links (just like the HTML output) instead of page references
    # This makes the output suitable for online browsing using a pdf viewer.

    print DOX_FD "PDF_HYPERLINKS        = NO\n";

    # If the LATEX_BATCHMODE tag is set to YES, doxygen will add the \\batchmode.
    # command to the generated LaTeX files. This will instruct LaTeX to keep
    # running if errors occur, instead of asking the user for help.
    # This option is also used when generating formulas in HTML.

    print DOX_FD "LATEX_BATCHMODE       = NO\n";

    #---------------------------------------------------------------------------
    # configuration options related to the RTF output
    #---------------------------------------------------------------------------

    # If the GENERATE_RTF tag is set to YES Doxygen will generate RTF output
    # For now this is experimental and is disabled by default. The RTF output
    # is optimised for Word 97 and may not look too pretty with other readers
    # or editors.

    print DOX_FD "GENERATE_RTF          = NO\n";

    # The RTF_OUTPUT tag is used to specify where the RTF docs will be put.
    # If a relative path is entered the value of OUTPUT_DIRECTORY will be
    # put in front of it. If left blank `rtf' will be used as the default path.

    print DOX_FD "RTF_OUTPUT            = rtf\n";

    # If the COMPACT_RTF tag is set to YES Doxygen generates more compact
    # RTF documents. This may be useful for small projects and may help to
    # save some trees in general.

    print DOX_FD "COMPACT_RTF           = NO\n";

    # If the RTF_HYPERLINKS tag is set to YES, the RTF that is generated
    # will contain hyperlink fields. The RTF file will
    # contain links (just like the HTML output) instead of page references.
    # This makes the output suitable for online browsing using a WORD or other.
    # programs which support those fields.
    # Note: wordpad (write) and others do not support links.

    print DOX_FD "RTF_HYPERLINKS        = NO\n";

    # Load stylesheet definitions from file. Syntax is similar to doxygen's
    # config file, i.e. a series of assigments. You only have to provide
    # replacements, missing definitions are set to their default value.

    print DOX_FD "RTF_STYLESHEET_FILE   = \n";

    #---------------------------------------------------------------------------
    # configuration options related to the man page output
    #---------------------------------------------------------------------------

    # If the GENERATE_MAN tag is set to YES (the default) Doxygen
    # will generate man pages

    print DOX_FD "GENERATE_MAN         = NO\n";

    # The MAN_OUTPUT tag is used to specify where the man pages
    # will be put.  If a relative path is entered the value of
    # OUTPUT_DIRECTORY will be put in front of it. If left blank
    # `man' will be used as the default path.

    print DOX_FD "MAN_OUTPUT           =\n";

    # The MAN_EXTENSION tag determines the extension that is added
    # to the generated man pages (default is the subroutine's
    # section .3)

    print DOX_FD "MAN_EXTENSION        = .3\n";

    #---------------------------------------------------------------------------
    # Configuration options related to the preprocessor
    #---------------------------------------------------------------------------

    # If the ENABLE_PREPROCESSING tag is set to YES (the default)
    # Doxygen will evaluate all C-preprocessor directives found in
    # the sources and include files.

    print DOX_FD "ENABLE_PREPROCESSING = YES\n";

    # If the MACRO_EXPANSION tag is set to YES Doxygen will expand
    # all macro names in the source code. If set to NO (the
    # default) only conditional compilation will be performed.

    print DOX_FD "MACRO_EXPANSION      = NO\n";

    # If the EXPAND_ONLY_PREDEF and MACRO_EXPANSION tags are both set to YES
    # then the macro expansion is limited to the macros specified with the
    # PREDEFINED and EXPAND_AS_PREDEFINED tags.

    print DOX_FD "EXPAND_ONLY_PREDEF    = NO\n";

    # If the SEARCH_INCLUDES tag is set to YES (the default) the
    # includes files in the INCLUDE_PATH (see below) will be
    # search if a #include is found.

    print DOX_FD "SEARCH_INCLUDES      = YES\n";

    # The INCLUDE_PATH tag can be used to specify one or more
    # directories that contain include files that are not input
    # files but should be processed by the preprocessor.

    print DOX_FD "INCLUDE_PATH         =\n";

    # You can use the INCLUDE_FILE_PATTERNS tag to specify one or more wildcard
    # patterns (like *.h and *.hpp) to filter out the header-files in the
    # directories. If left blank, the patterns specified with FILE_PATTERNS will
    # be used.

    print DOX_FD "INCLUDE_FILE_PATTERNS = \n";

    # The PREDEFINED tag can be used to specify one or more macro
    # names that are defined before the preprocessor is started
    # (similar to the -D option of gcc). The argument of the tag
    # is a list of macros of the form: name or name=definition (no
    # spaces). If the definition and the = are omitted =1 is
    # assumed.

    print DOX_FD "PREDEFINED           = \n";

    # If the MACRO_EXPANSION and EXPAND_PREDEF_ONLY tags are set to YES then
    # this tag can be used to specify a list of macro names that should be expanded.
    # The macro definition that is found in the sources will be used.
    # Use the PREDEFINED tag if you want to use a different macro definition.

    print DOX_FD "EXPAND_AS_DEFINED     = \n";

    #---------------------------------------------------------------------------
    # Configuration options related to external references
    #---------------------------------------------------------------------------

    # The TAGFILES tag can be used to specify one or more
    # tagfiles.

    print DOX_FD "TAGFILES             =\n";

    # When a file name is specified after GENERATE_TAGFILE,
    # doxygen will create a tag file that is based on the input
    # files it reads.

    print DOX_FD "GENERATE_TAGFILE     = $project_out_dir/doc/apiref/IGUANA.tag\n";

    # If the ALLEXTERNALS tag is set to YES all external classes
    # will be listed in the class index. If set to NO only the
    # inherited external classes will be listed.

    print DOX_FD "ALLEXTERNALS         = NO\n";

    # The PERL_PATH should be the absolute path and name of the
    # perl script interpreter (i.e. the result of `which perl').

    print DOX_FD "PERL_PATH            = /usr/bin/perl\n";

    #---------------------------------------------------------------------------
    # Configuration options related to the dot tool
    #---------------------------------------------------------------------------

    # If you set the HAVE_DOT tag to YES then doxygen will assume the dot tool is
    # available from the path. This tool is part of Graphviz, a graph visualization
    # toolkit from AT&T and Lucent Bell Labs. The other options in this section
    # have no effect if this option is set to NO (the default)

    print DOX_FD "HAVE_DOT              = YES\n";

    # If the CLASS_GRAPH and HAVE_DOT tags are set to YES then doxygen
    # will generate a graph for each documented class showing the direct and
    # indirect inheritance relations. Setting this tag to YES will force the
    # the CLASS_DIAGRAMS tag to NO.

    print DOX_FD "CLASS_GRAPH           = YES\n";

    # If the COLLABORATION_GRAPH and HAVE_DOT tags are set to YES then doxygen
    # will generate a graph for each documented class showing the direct and
    # indirect implementation dependencies (inheritance, containment, and
    # class references variables) of the class with other documented classes.

    print DOX_FD "COLLABORATION_GRAPH   = YES\n";

    # If the ENABLE_PREPROCESSING, INCLUDE_GRAPH, and HAVE_DOT tags are set to
    # YES then doxygen will generate a graph for each documented file showing
    # the direct and indirect include dependencies of the file with other
    # documented files.

    print DOX_FD "INCLUDE_GRAPH         = NO\n";

    # If the ENABLE_PREPROCESSING, INCLUDED_BY_GRAPH, and HAVE_DOT tags are set to
    # YES then doxygen will generate a graph for each documented header file showing
    # the documented files that directly or indirectly include this file

    print DOX_FD "INCLUDED_BY_GRAPH     = NO\n";

    # If the GRAPHICAL_HIERARCHY and HAVE_DOT tags are set to YES then doxygen
    # will graphical hierarchy of all classes instead of a textual one.

    print DOX_FD "GRAPHICAL_HIERARCHY   = NO\n";

    # The tag DOT_PATH can be used to specify the path where the dot tool can be
    # found. If left blank, it is assumed the dot tool can be found on the path.

    print DOX_FD "DOT_PATH              = \n";

    # The MAX_DOT_GRAPH_WIDTH tag can be used to set the maximum allowed width
    # (in pixels) of the graphs generated by dot. If a graph becomes larger than
    # this value, doxygen will try to truncate the graph, so that it fits within
    # the specified constraint. Beware that most browsers cannot cope with very
    # large images.

    print DOX_FD "MAX_DOT_GRAPH_WIDTH   = 1024\n";

    # The MAX_DOT_GRAPH_HEIGHT tag can be used to set the maximum allows height
    # (in pixels) of the graphs generated by dot. If a graph becomes larger than
    # this value, doxygen will try to truncate the graph, so that it fits within
    # the specified constraint. Beware that most browsers cannot cope with very
    # large images.

    print DOX_FD "MAX_DOT_GRAPH_HEIGHT  = 1024\n";

    #---------------------------------------------------------------------------
    # Configuration options related to the search engine
    #---------------------------------------------------------------------------

    # The SEARCHENGINE tag specifies whether or not a search
    # engine should be used. If set to NO the values of all tags
    # below this one will be ignored.

    print DOX_FD "SEARCHENGINE         = NO\n";

    # The CGI_NAME tag should be the name of the CGI script that
    # starts the search engine (doxysearch) with the correct
    # parameters.  A script with this name will be generated by
    # doxygen.

    print DOX_FD "CGI_NAME             = search.cgi\n";

    # The CGI_URL tag should be the absolute URL to the directory
    # where the cgi binaries are located. See the documentation of
    # your http daemon for details.

    print DOX_FD "CGI_URL              =\n";

    # The DOC_URL tag should be the absolute URL to the directory
    # where the documentation is located. If left blank the
    # absolute path to the documentation, with file:// prepended
    # to it, will be used.

    print DOX_FD "DOC_URL              =\n";

    # The DOC_ABSPATH tag should be the absolute path to the
    # directory where the documentation is located. If left blank
    # the directory on the local machine will be used.

    print DOX_FD "DOC_ABSPATH          =\n";

    # The BIN_ABSPATH tag must point to the directory where the
    # doxysearch binary is installed.

    print DOX_FD "BIN_ABSPATH          = \n";

    # The EXT_DOC_PATHS tag can be used to specify one or more
    # paths to documentation generated for other projects. This
    # allows doxysearch to search the documentation for these
    # projects as well.

    print DOX_FD "EXT_DOC_PATHS        = \n";
    close DOX_FD;
}
