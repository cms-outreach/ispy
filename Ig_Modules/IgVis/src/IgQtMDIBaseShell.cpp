#include "Ig_Modules/IgVis/interface/IgQtMDIBaseShell.h"

#include <Inventor/Qt/SoQt.h>
#include <Inventor/Qt/viewers/SoQtExaminerViewer.h>

#include <Inventor/nodes/SoClipPlane.h>
#include <Inventor/fields/SoSFBool.h>

#include <Inventor/SbLinear.h>
#include <Inventor/SoInput.h>
#include <Inventor/actions/SoWriteAction.h>
#include <Inventor/nodes/SoSelection.h>
#include <Inventor/actions/SoBoxHighlightRenderAction.h>
#include <Inventor/actions/SoLineHighlightRenderAction.h>
#include <Inventor/nodes/SoSwitch.h>

#include <Inventor/nodes/SoDrawStyle.h>

#include "qapplication.h"
#include "qmainwindow.h"
#include "qworkspace.h"
#include "qmenubar.h"
#include "qvbox.h"
#include "qstatusbar.h"
#include "qfiledialog.h"
#include "qtooltip.h"
#include "qtextbrowser.h"
#include "qcursor.h"
#include "qdragobject.h"
#include "qfileinfo.h"
#include "qsizepolicy.h"
#include "qtoolbox.h"

#include "Ig_Modules/IgVis/interface/IgQtClipCtl.h"
#include "Ig_Modules/IgVis/interface/IgQtVisCtl.h"
#include "Ig_Modules/IgVis/interface/IgQtAnimCtl.h"
#include "Ig_Modules/IgVis/interface/IgQtBrowser.h"
#include "Ig_Modules/IgVis/interface/IgQtViewpointCtl.h"
#include "Ig_Modules/IgVis/interface/IgQtEventCtl.h"
#include "Ig_Modules/IgVis/interface/IgQtTwigCallbackStruct.h"
#include "Ig_Modules/IgVis/interface/IgQtInfoStream.h"
#include "Ig_Modules/IgVis/interface/IgQtAnim.h"

#include "Ig_Modules/IgVis/interface/IgQtMDITwigs.h"
#include "Ig_Modules/IgVis/interface/IgQtMDI.h"

#include "Ig_Modules/IgVis/interface/IgQtTwig.h"
#include "Ig_Modules/IgVis/interface/IgQtTwigController.h"
#include "Ig_Modules/IgVis/interface/IgQtEventCtl.h"
#include "Ig_Modules/IgVis/interface/IgQtMiscCtl.h"

#include "Ig_Modules/IgVis/interface/IgQtBrowser.h"
#include "Ig_Modules/IgVis/interface/IgQtResourceMgr.h"
#include "Ig_Modules/IgVis/interface/stars.xpm"

#include "Ig_Modules/IgVis/interface/IgQtPhysTabsImpl.h"
#include "Ig_Modules/IgVis/interface/IgQtTimerPrint.h"

#include "Ig_Modules/IgVis/interface/IgQtMDIShellBuilder.h"
#include "Ig_Modules/IgVis/interface/IgQtMDIShellFactory.h"


#include <fstream>
#include <typeinfo>


/*
* This hidden class is used when we need multiple views of the scene to allow for overlaping clip planes
* and similar doodads
*/
class IgQtSwitchTwig : public IgQtTwig
{
public:
    explicit 
	IgQtSwitchTwig(SbString name);
    virtual ~IgQtSwitchTwig(void){};
};
IgQtSwitchTwig::IgQtSwitchTwig(SbString name) : IgQtTwig(name)
{	
    SoSwitch *theSwitch = new SoSwitch;
    setIvNode(theSwitch);
}




// Maybe we should use a macro, much as I hate them... shellName must match className must be name of class
// and static to boot; the shell must be registered by creating a throw away
// static class which does the work during construction. The empty namespace is the
// same as static.
const QString IgQtMDIBaseShell::theShellName = QString( "IgQtMDIBaseShell" );
/* uncomment to make visible
namespace {
    IgQtShellRegisterEntry e( QString( "IgQtMDIBaseShell" ), IgQtMDIShellBuilder<IgQtMDIBaseShell>::getInstance(), QString( "Base Shell" ) );
}
*/
IgQtMDIBaseShell::IgQtMDIBaseShell(IgQtMDI *parent, SoQtFullViewer *aViewer, bool buildnow): 
IgQtMDIAbsShell(parent,aViewer,false), staticTwig(0), adorn(true)
{
    constructor(buildnow);
}
IgQtMDIBaseShell::IgQtMDIBaseShell(IgQtMDI *parent, SoQtFullViewer *aViewer): 
IgQtMDIAbsShell(parent,aViewer,false), staticTwig(0), adorn(true)
{
    constructor(true);
}
void IgQtMDIBaseShell::constructor(bool build)
{
    setUniqueName(className()); //overwrites the name generated by AbsShell

    if (!build) return;

    QWidget *view = new QWidget(this);
    bool wasMaximized = isMaximized();
    if (wasMaximized)
    {
	this->hide();
    }

    setCentralWidget(view);
    buildWidget(view);
    if (wasMaximized) this->showMaximized();
    parentMDI->addBrowser( this );
}
void IgQtMDIBaseShell::buildWidget(QWidget *view)
{
    // Render area related items
    if (!theViewer) theViewer = new IgQtBrowser( view, "Scan" );
    topTwig = new IgQtTwig( "Top" ); 
    theViewer->setSceneGraph( topTwig->getIvNode() );
    // add the scene after the environment: see below
    sceneTwig = new IgQtTwig( "Scene" );
    // want scene to be selectable for picking
    sceneTwig->makeSelectable();

    IgQtTwigCallbackStruct *selectCBStruct = 
	new IgQtTwigCallbackStruct( sceneTwig, theViewer->getSceneManager() );
    if ( sceneTwig->getIvNode()->getTypeId().isDerivedFrom( SoSelection::getClassTypeId() ) ) 
    {
	SoSelection *selectNode = static_cast<SoSelection*>(sceneTwig->getIvNode());
	selectNode->policy.setValue(SoSelection::SHIFT);
	//TODO: pick filter has stopped working
	selectNode->addSelectionCallback(IgQtTwig::selectionCB, selectCBStruct);
	selectNode->setPickFilterCallback(IgQtTwig::pickCB, selectCBStruct);
	theViewer->redrawOnSelectionChange(selectNode);

	theViewer->setGLRenderAction(new SoLineHighlightRenderAction); //Box is the alternative
    }

    // for tool tips
    QStatusBar *aBar = this->statusBar();
    QToolTipGroup *ttg = toolTipGroup();
    connect(ttg, SIGNAL(showTip(const QString&)),
	aBar, SLOT(message(const QString&)) );
    connect(ttg, SIGNAL(removeTip()),
	aBar, SLOT(clear()) );



    //  File Menu
    file = new QPopupMenu(this);
    file->insertItem("&Open", this, SLOT(openIv()));
    file->insertItem("&Save as", this, SLOT(saveIv()));
    printID = file->insertItem("&Print as");
    file->insertItem("Add Info",this, SLOT(adornSlot()));
    file->insertItem("Clone Scene",this, SLOT(cloneSlot()));
    //  int prefs = file->insertItem("Preferences",this,SLOT(preferencesSlot()));
    //  file->setItemEnabled(prefs, false); // not yet ready for prime-time
    // move this into a constructor once we've got a real preferences object
    thePrefWidget = new IgQtPhysTabsImpl(this->parentWidget(),"Preferences");
    thePrefWidget->setCaption("Preferences");
    file->insertItem("Close and Delete", this, SLOT(closeSlot()));
    this->menuBar()->insertItem("File",file);

    //GOA_SOQT
    //  file->connectItem(printID,theViewer,SLOT(printSlot()));
    if (QObject *obj = dynamic_cast<QObject*>(theViewer)) {
	file->connectItem(printID,obj,SLOT(printSlot()));
    }


    // Light Menu (must come before the clips are created)
    lights = new IgQtVisCtl(this,topTwig->getIvNode());
    this->menuBar()->insertItem("Lights",lights);
    QToolTip::add(lights,"Control Additional Lighting"
	,ttg, "Add or delete lights");

    // Clip control menu
    clips = new IgQtClipCtl(this,topTwig->getIvNode());
    this->menuBar()->insertItem("Clips",clips);
    QToolTip::add(clips,"Control Clip Planes"
	,ttg,"Add/delete/control clip planes");

    // Animation control menu
    anim = new IgQtAnimCtl(this,topTwig->getIvNode());
    this->menuBar()->insertItem("Anims",anim);
    QToolTip::add(anim,"Control Animation"
	,ttg,"Rotate the scene automatically");

    // Viewpoint control menu
    views = new IgQtViewpointCtl(this,theViewer);
    this->menuBar()->insertItem("Viewpoints",views);
    QToolTip::add(views,"Control Viewpoints"
	,ttg,"Set Camera Viewpoint");

    // Miscellaneous items menu
    // not all browsers may able to support all operations
    misc = new IgQtMiscCtl(this,topTwig->getIvNode(),theViewer);
    this->menuBar()->insertItem("Misc",misc);
    QToolTip::add(misc,"Miscellaneous Controls",
	ttg,"Z Slicer...");
    connect(misc,SIGNAL(wireframeSignal(bool)),this,SLOT(setStaticWireframe(bool)));
    connect(misc,SIGNAL(cutawaySignal(bool)),this,SLOT(setCutAway(bool)));
    connect(misc,SIGNAL(optimiseSignal(bool)),this,SLOT(setOptimiseStatics(bool)));

    // finally, physics... may want to extract to its own control
    //  Physics Controls Menu
    tabs = new IgQtPhysTabs(NULL,"PhysTabs");
    physCtl = new QPopupMenu(this);
    this->menuBar()->insertItem("Physics",physCtl);
    QToolTip::add(physCtl,"Controls and Settings for Physics",
	ttg,"Physics Controls");
    physCtl->insertItem("General", this, SLOT(generalPhysicsSlot()));

    // Physics events menu
    evt = new IgQtEventCtl(this);
    this->menuBar()->insertItem("&Events",evt);
    QToolTip::add(evt,"Event Control",ttg,"Get Events");

    // finally add the topTwig
    topTwig->addChild(sceneTwig);

    // enable filename drops
    setAcceptDrops(true);

    // set an icon for the window
    setIcon(QPixmap(( const char** ) stars_xpm));

    resize( 350, 350 );

    aBar->message( "Ready", 2000 );
    ttg->setEnabled(true);

}
void IgQtMDIBaseShell::openIv()
{
    const QString f = QFileDialog::getOpenFileName( QString::null, "*.iv", this );
    openIvP(f);

}
void IgQtMDIBaseShell::openIvP(const QString f)
{
    // start at the current working directory and with *.iv as filter
    const bool buildTree = true; // TODO: move (w/ other options) to open dialog box.
    if ( !f.isEmpty() ) {
	// the user selected a valid existing file
	SoInput myInput;
	if (myInput.openFile(f.latin1())) 
	{
	    QFileInfo fi(f);
	    SoSeparator *node = SoDB::readAll(&myInput);
	    if (node && buildTree) {
		if (!caption()) {
		    setCaption(f);
		}
		IgQtTwig *tree = IgQtTwig::addTwigFromScratch(node,false); //will recurse down
		QFileInfo fileInfo(f);
		addStaticTwig(tree,fileInfo.baseName());

		// scan the new scene for additional environmental controls 
		clips->addAllIv(node);
		lights->addAllIv(node);
		views->addAllIv(node);
	    }
	} else {
	    // the user cancelled the dialog or there was a read error
	}
    }

}
void IgQtMDIBaseShell::saveIv()
{
    // start at the current working directory and with *.iv as filter
    QFileDialog saveDialog(this,"saveIvDialog",true);
    saveDialog.setMode( QFileDialog::AnyFile );
    QString binary("Binary OIV Files (*.iv)");
    QString ascii("ASCII OIV Files (*.iv)");
    QStringList filters(ascii);
    filters.append(binary);
    saveDialog.setFilters(filters);
    if (saveDialog.exec() == QDialog::Accepted) {
	QString f = saveDialog.selectedFile();
	SoOutput myOutput;
	f += QString(".iv");
	if (myOutput.openFile(f.latin1())) 
	{
	    myOutput.setBinary(saveDialog.selectedFilter()==binary);
	    SoWriteAction writeOut(&myOutput);
	    //TODO: switch to determine whether or not we should start at topTwig or sceneTwig
	    writeOut.apply(topTwig->getIvNode());

	} else {
	    // the user cancelled the dialog
	}
    }
}
void IgQtMDIBaseShell::closeSlot()
{
    // this method is the moral equivalent of a d-tor, but we just close instead of deleting
    for (List_of_MDITwigs::iterator it = twigWidgets.begin(); it != twigWidgets.end(); it++)
    {
	(*it)->close(true);
    }
    delete sceneTwig;
    delete topTwig;
    close(true);
}
void IgQtMDIBaseShell::cloneSlot()
{
    IgQtMDIBaseShell *newShell;
    if (parentMDI) {
	newShell = new IgQtMDIBaseShell(parentMDI);
#ifndef __COIN_
	// IMPORTANT: make sure each GL context has a unique cache context
	// id.  this is needed for TGS/SGI Inventor. Coin handles this
	// automatically.
	newShell->theViewer->getGLRenderAction()->setCacheContext(++IgQtMDIAbsShell::contextcnt);
#endif

	SoGroup *aNode = const_cast<SoGroup*>(sceneTwig->getIvNode());
	SoGroup *anotherNode = const_cast<SoGroup*>(newShell->sceneTwig->getIvNode());
	anotherNode->addChild(aNode);
	newShell->showNormal();
    }
}
void IgQtMDIBaseShell::adornSlot()
{
    // generates the adorning widgets from the staticTwig
    // sub-classes should include (e.g.) the volatileTwigs
    if (staticTwig)
    {
	addTwigWidget(staticTwig);
	addInfoStreamWidget(staticTwig);
    }
}
void IgQtMDIBaseShell::eventsSlot()
{
    // there is supposed to be someone out there
    // who can provide us with a new event...
    emit newEvent();
}
void IgQtMDIBaseShell::eventNotifySlot()
{	
    // we arrive here upon notification that
    // a new event has been provided for us

    QStatusBar* aBar = this->statusBar();
    aBar->message( "Processing an Event");
    QApplication::setOverrideCursor( waitCursor );

    // event processing here
    killVolatileTwigs();

    aBar->message( "Event Processed", 2000 );
    QApplication::restoreOverrideCursor();

}
void IgQtMDIBaseShell::clearVolatileTwigs(void)
{
    for (std::list<IgQtInfoStream*>::iterator it = infoList.begin(); it != infoList.end(); it++) 
    {
	(*it)->clear();
    }
    for (List_of_Twigs::iterator it=volatileTwigs.begin(); it != volatileTwigs.end(); it++)
    {
	(*it)->clearTree();
	(*it)->drawTree();
    }
}
void IgQtMDIBaseShell::killVolatileTwigs(void)
{
    // kill all previous volatile twigs; TODO: what if we have volatiles not directly attached
    // to the sceneTwig? 

    // Iterator blows up if we continue after the erase. Implemented additional checks.
    for (List_of_Twigs::iterator it=volatileTwigs.begin(); it != volatileTwigs.end(); it++)
    {
	// if more than one twig share the same controller, the first one kills it
	// others can't find it in the list
	IgQtTwigController *ctl = (*it)->getController();
	if (ctl) {
	    bool cont_inner = true;
	    for (List_of_MDITwigs::iterator itt = twigWidgets.begin(); (itt != twigWidgets.end()) && cont_inner; itt++)
	    {
		if ((*itt) == ctl->parentWidget(false))
		{
		    (*itt)->close(true); // close and delete the widget
		    twigWidgets.erase(itt);
		    cont_inner = false;
		}
	    }
	}
	sceneTwig->removeChild((*it));
    }
    volatileTwigs.clear();
}
void IgQtMDIBaseShell::autoPrintViewsSlot(bool itemOn)
{
    if (itemOn)
    {
	saved_adorn = adorn;
	adorn = false;
	IgQtTimerPrint *tp = IgQtTimerPrint::getTheTimerPrint();
	IgQtBrowser *browser = dynamic_cast<IgQtBrowser*>(theViewer);
	tp->setBrowser(browser);
	connect(tp,SIGNAL(newEventRequest()),this,SLOT(eventsSlot()));		
	tp->setTimerPrintOn(true);
    }
    else
    {
	adorn = saved_adorn;
	IgQtTimerPrint *tp = IgQtTimerPrint::getTheTimerPrint();
	tp->setTimerPrintOn(false);
	tp->setBrowser(NULL);
    }
}

void IgQtMDIBaseShell::autoEventsSlot(bool itemOn)
{
    if (itemOn)
    {
	saved_adorn = adorn;
	adorn = false;
	IgQtAnim *currentAnim = anim->getAnimator();
	connect(currentAnim,SIGNAL(newEventRequest()),
	    this,SLOT(eventsSlot()));
	//GOA_SOQT
	//		connect(currentAnim,SIGNAL(axisReset(int)),theViewer,SLOT(printDefSlot(int)));
	if (QObject *obj = dynamic_cast<QObject*>(theViewer)) {
	    connect(currentAnim,SIGNAL(axisReset(int)),obj,SLOT(printDefSlot(int)));
	}
	currentAnim->on().setValue(true);
    }
    else
    {
	adorn = saved_adorn;
	IgQtAnim *currentAnim = anim->getAnimator();
	currentAnim->on().setValue(false);
	disconnect(currentAnim,SIGNAL(newEventRequest()),
	    this,SLOT(eventsSlot()));
	//GOA_SOQT
	//		disconnect(currentAnim,SIGNAL(axisReset(int)),theViewer,SLOT(printDefSlot(int)));
    }
}
void IgQtMDIBaseShell::addScene(IgQtTwig *twig, const QString &f)
{
    QString sceneTitle = f;
    if (f==QString::null) 
    {
	sceneTitle = QString((twig->getName()).getString());
    }
    addTwig(twig);
    twig->drawTree();
    if (adorn) 
    {
	addTwigWidget(twig,sceneTitle+"_tree");
	addInfoStreamWidget(twig,sceneTitle+"_info");
    }

}
void IgQtMDIBaseShell::addTwig(IgQtTwig *twig)
{
    //TODO: fill in the details for when we need to build the TwigController
    sceneTwig->addChild(twig);

}
void IgQtMDIBaseShell::addVolatileTwig(IgQtTwig *twig, const QString &f)
{
    QString sceneTitle = f;
    if (f==QString::null) 
    {
	sceneTitle = QString((twig->getName()).getString());
    }
    volatileTwigs.push_back(twig);
    addTwig(twig);
    twig->drawTree();
    if (adorn) 
    {
	addTwigWidget(twig,sceneTitle+"_tree");
	addInfoStreamWidget(twig,sceneTitle+"_info");
    }

}
void IgQtMDIBaseShell::addStaticTwig(IgQtTwig *twig, const QString & /*f*/)
{
    if (!staticTwig) 
    {
	staticTwig = new IgQtTwig("Static");
	//insert a hidden node before the staticTwig so that we can have multiple paths (selected by a switch)
	IgQtSwitchTwig *hidden = new IgQtSwitchTwig("Hidden");
	IgQtTwigSeparator *node = hidden->getIvNode(); //probably ought to over-ride the return type
	if (node->isOfType(SoSwitch::getClassTypeId()))
	{
	    SoSwitch *tripleSwitch = static_cast<SoSwitch*>(node);
	    hidden->addChild(staticTwig); // sets the normal scene as node 0 of the switch
	    tripleSwitch->whichChild = 0;
	    sceneTwig->addChild(hidden);

	    SoSeparator *sepA = new SoSeparator;
	    SoSeparator *sepB = new SoSeparator;
	    SoClipPlane *clipA = new SoClipPlane;
	    SoClipPlane *clipB = new SoClipPlane;
	    clipA->plane = SbPlane(SbVec3f(-1.F,0.F,0.F),0.F);
	    clipB->plane = SbPlane(SbVec3f(-0.5F,-0.8664F,0.F),0.F);
	    sepA->addChild(clipA);
	    sepA->addChild(staticTwig->getIvNode());
	    sepB->addChild(clipB);
	    sepB->addChild(staticTwig->getIvNode());
	    SoSeparator *sepC = new SoSeparator;
	    sepC->addChild(sepA);
	    sepC->addChild(sepB);
	    tripleSwitch->addChild(sepC); //sets the pair of cut planes as node 1 of the switch
	}
	// add a wireframe node with a switch; default is to off.
	SoSwitch *theSwitch = new SoSwitch;
	SoDrawStyle *wf = new SoDrawStyle;
	wf->style = SoDrawStyle::LINES;
	theSwitch->addChild(wf);
	theSwitch->whichChild = SO_SWITCH_NONE;
	staticTwig->getIvNode()->addChild(theSwitch);
    }

    staticTwig->addChild(twig);

}
IgQtMDITwigs* IgQtMDIBaseShell::addTwigWidget(IgQtTwig *twig, QString title, QWidget* /* ws */)
{
    if (!title) title = caption() + "_tree";
    // make a widget for the twigs
    IgQtMDITwigs *twigWidget = NULL;

    if (parentMDI)
    {
	QToolBox *box = parentMDI->twigbox();
	twigWidget = new IgQtMDITwigs(box,title);
	box->addItem(twigWidget, title);
	IgQtTwigController *theTwigController = new IgQtTwigController(twigWidget,title+"_controller");
	twig->createList(theTwigController);
	twigWidgets.push_back(twigWidget);
	// TODO: connect the close signal from the widget to us so we can update the list
	twigWidget->showNormal();
    }

    return twigWidget;
}

IgQtInfoStream* IgQtMDIBaseShell::addInfoStreamWidget(IgQtTwig *twig, QString title, QWidget* /* ws */)
{
    if (!title) title = caption() + "_info";
    IgQtInfoStream *info = NULL;
    if (parentMDI) {
	info = IgQtInfoStream::getDefaultInfoStream( parentMDI->infobox() );
	if ( !parentMDI->infobox()->count() )
	{
	    parentMDI->infobox()->addItem( info->getWidget(), tr("Info") );
	}
	twig->setOstream( *info ); //over-ride default output stream with info stream
	infoList.push_back( info );
	// TODO: connect the close signal from the widget to us so we can update the list
	info->show();
    }
    return info;
}
void IgQtMDIBaseShell::dragEnterEvent(QDragEnterEvent* event)
{

    event->accept(QUriDrag::canDecode(event));

}
void IgQtMDIBaseShell::dropEvent(QDropEvent* event)
{	
    QStringList files;

    if ( QUriDrag::decodeLocalFiles(event, files) ) {
	for ( QStringList::Iterator it = files.begin(); it != files.end(); ++it ) {
	    openIvP(*it);
	}		
    } 	
}
QDomElement IgQtMDIBaseShell::shellToXML() const
{
    // widget params are stored in base class
    QDomElement de = IgQtMDIAbsShell::shellToXML();

    IgQtResourceMgr& theMgr = IgQtResourceMgr::getInstance();
    de.setAttribute("resourceID",getUniqueName()); //over-ride existing value
    // TODO (20031216) other settings: to come... o wireframe, o cut-away, o bkg colour

    // twigs
    QDomDocument &theDoc = theMgr.getDoc(true);
    QDomElement det = theDoc.createElement( "twigs" );
    de.appendChild( det );

    // save the twig properties
    int i=0;
    for (List_of_Twigs::const_iterator it = volatileTwigs.begin(); it != volatileTwigs.end(); it++)
    {
	QString number;
	number.setNum(i);
	det.appendChild( (*it)->twigToXML() );
    }
    if (staticTwig)
    {
	QString id = getUniqueName();
	det.appendChild( staticTwig->twigToXML(  ) );
    }
    // this is for viewpoints
    views->newIgCtlItem("Last Viewpoint", true);
    views->saveResources( getUniqueName(), de );
    // lights
    lights->saveResources( getUniqueName(), de );
    return de;
}
bool IgQtMDIBaseShell::xmlToShell( QDomElement &de )
{
    // restore widget parameters

    IgQtMDIAbsShell::xmlToShell( de );

    //
    // Restore the twigs
    //
    QDomElement qe = de.namedItem( "twigs" ).toElement();
    // check that number of top twigs stored is same as current
    if ( volatileTwigs.size() + (staticTwig==NULL ? 0 : 1) ==  qe.childNodes().length() )
    {
	QDomNodeList nl = qe.childNodes();
	int ie = 0; // counter for twigs in the xml
	for (List_of_Twigs::iterator it = volatileTwigs.begin(); it != volatileTwigs.end(); it++)
	{
	    if ( (*it)->xmlToTwig( nl.item(ie).toElement() ) )
	    {
		(*it)->drawTree();
		ie++;
	    }
	}
	if (staticTwig  &&  staticTwig->xmlToTwig( nl.item(ie).toElement() ) )
	{
	    staticTwig->drawTree();
	    ie++;
	}
    }

    // Restore the viewpoints
    qe = de.namedItem( "viewpoints" ).toElement();
    views->restoreResources( getUniqueName(), qe );

    // Restore the light settings
    qe = de.namedItem( "lights" ).toElement();
    lights->restoreResources( getUniqueName(), qe );

    return true;
}

void IgQtMDIBaseShell::setStaticWireframe(bool on)
{
    if (!staticTwig) return; //ignore non-sensical request
    IgQtTwigSeparator *node = staticTwig->getIvNode();

    if (node->getChild(0)->isOfType(SoSwitch::getClassTypeId()))
    {
	SoSwitch *theSwitch = static_cast<SoSwitch*>(node->getChild(0));
	theSwitch->whichChild = on ? SO_SWITCH_ALL : SO_SWITCH_NONE;
    }
}
void IgQtMDIBaseShell::setCutAway(bool on)
{
    //! this whole operation is very fragile, really only for testing-- breaks all rules for twigs
    if (!staticTwig) return; //ignore non-sensical request

    IgQtTwigSeparator *node = staticTwig->getParentIvNode();	
    if (node && node->isOfType(SoSwitch::getClassTypeId()))
    {
	SoSwitch *theSwitch = static_cast<SoSwitch*>(node);
	theSwitch->whichChild = on ? 1 : 0;
    }
}
void IgQtMDIBaseShell::setOptimiseStatics(bool /*on*/)
{
    if (!staticTwig) return; //ignore non-sensical request
    staticTwig->optimise();

}

IgQtMDIBaseShell::~IgQtMDIBaseShell()
{
    if (staticTwig) delete staticTwig;
}
// slot to pop-up physics controls
void IgQtMDIBaseShell::generalPhysicsSlot()
{
    tabs->show();
}
// slot to pop-up preferences sheet(s)
void IgQtMDIBaseShell::preferencesSlot()
{
    thePrefWidget->show();
}
const QString IgQtMDIBaseShell::shellName()
{
	return theShellName;
}
