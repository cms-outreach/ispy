### PATCH xml.c.diff
--- xml.c	Wed Mar  5 14:48:11 2003
+++ ../.src/gccxml/0.4.2/gccxml-0.4.2/xml.c	Wed Oct  8 07:08:43 2003
@@ -25,10 +25,27 @@
    for common attribute name/pair values.
 */
 
+/* Use GCC_XML_GCC_VERSION to modify code based on the version of GCC
+   in which we are being built.  This is set in the patched version of
+   cp-tree.h.  The format is 0xMMmmpp, where MM is the major version
+   number, mm is the minor version number, and pp is the patch level.
+   Examples:  gcc 3.0.4 = 0x030004
+              gcc 3.2.0 = 0x030200  */
+
 #include "config.h"
 #include "system.h"
 #include "sys/stat.h"
 
+/* GCC 3.3 and above need these headers here.  The GCC-XML patches for
+   these versions define GCC_XML_GCC_VERSION in config.h instead of
+   cp-tree.h, so the macro is available here.  The patches for older
+   versions may provide the macro in cp-tree.h, but in that case
+   we don't need these headers anyway.  */
+#if defined(GCC_XML_GCC_VERSION) && (GCC_XML_GCC_VERSION >= 0x030300)
+# include "coretypes.h"
+# include "tm.h"
+#endif
+
 #include "tree.h"
 #include "cp-tree.h"
 #include "decl.h"
@@ -37,12 +54,7 @@
 
 #include "splay-tree.h"
 
-/* Use GCC_XML_GCC_VERSION to modify code based on the version of GCC
-   in which we are being built.  This is set in the patched version of
-   cp-tree.h.  The format is 0xMMmmpp, where MM is the major version
-   number, mm is the minor version number, and pp is the patch level.
-   Examples:  gcc 3.0.4 = 0x030004
-              gcc 3.2.0 = 0x030200  */
+/* Decide how to call cp_error.  */
 #if defined(GCC_XML_GCC_VERSION) && (GCC_XML_GCC_VERSION >= 0x030100)
 # define XML_CP_ERROR cp_error_at
 #else
@@ -50,6 +62,11 @@
 # define XML_HAVE_FAKE_STD_NODE
 #endif
 
+/* Decide how to access base classes.  */
+#if !defined(GCC_XML_GCC_VERSION) || (GCC_XML_GCC_VERSION < 0x030300)
+# define XML_PRE_3_3_TREE_VIA_PUBLIC
+#endif
+
 /* A "dump node" corresponding to a particular tree node.  */
 typedef struct xml_dump_node
 {
@@ -64,7 +81,7 @@
 typedef struct xml_dump_queue
 {
   /* The queued tree node.  */
-  tree node;
+  tree tree_node;
 
   /* The corresponding dump node.  */
   xml_dump_node_p dump_node;
@@ -77,7 +94,7 @@
 typedef struct xml_file_queue
 {
   /* The queued file name.  */
-  splay_tree_node node;
+  splay_tree_node tree_node;
 
   /* The next node in the queue.  */
   struct xml_file_queue *next;
@@ -138,6 +155,13 @@
 static const char* xml_get_encoded_string_from_string PARAMS ((const char*));
 static tree xml_get_encoded_identifier_from_string PARAMS ((const char*));
 
+/* Switch to 1 to enable debugging of dump node selection.  */
+#if 0
+# define xml_add_node(xdi, node, complete)                                    \
+   (fprintf(stderr, "Adding node at line %d\n", __LINE__),                    \
+    xml_add_node(xdi, node, complete))
+#endif
+
 /* Main XML output function.  Called by parser at the end of a translation
    unit.  Walk the entire translation unit starting at the global
    namespace.  Output all declarations.  */
@@ -267,7 +291,7 @@
   
   /* Point the queue node at its corresponding tree node and dump node.  */
   dq->next = 0;
-  dq->node = t;
+  dq->tree_node = t;
   dq->dump_node = dn;
   
   /* Add it to the end of the queue.  */
@@ -342,7 +366,7 @@
     {
     /* Get the next queue entry.  */
     xml_dump_queue_p dq = xdi->queue;
-    tree t = dq->node;
+    tree t = dq->tree_node;
     xml_dump_node_p dn = dq->dump_node;
     
     /* Remove the entry from the queue.  */
@@ -388,8 +412,8 @@
     fq = (xml_file_queue_p) xmalloc (sizeof (struct xml_file_queue));
 
     /* Create a new entry in the splay-tree.  */
-    fq->node = splay_tree_insert (xdi->file_nodes, (splay_tree_key) t, 
-                                  (splay_tree_value) index);
+    fq->tree_node = splay_tree_insert (xdi->file_nodes, (splay_tree_key) t, 
+                                       (splay_tree_value) index);
     
     /* Add it to the end of the queue.  */
     fq->next = 0;
@@ -635,6 +659,36 @@
   fprintf (xdi->file, " min=\"0\" max=\"%s\"", length);
 }
 
+/* Print XML attribute listing types that this type can throw.  */
+static void
+xml_print_throw_attribute(xml_dump_info_p xdi, tree ft, int complete)
+{
+  tree raises = TYPE_RAISES_EXCEPTIONS (ft);
+  if(raises)
+    {
+    fprintf (xdi->file, " throw=\"");
+    if(TREE_VALUE (raises))
+      {
+      for (;
+           raises != NULL_TREE; raises = TREE_CHAIN (raises))
+        {
+        tree t = TREE_VALUE (raises);
+        const char* ch_const = "";
+        const char* ch_volatile = "";
+        const char* ch_restrict = "";
+        int id = xml_add_node (xdi, TYPE_MAIN_VARIANT (t), complete);
+        if (CP_TYPE_CONST_P (t)) { ch_const = "c"; }
+        if (CP_TYPE_VOLATILE_P (t)) { ch_volatile = "v"; }
+        if (CP_TYPE_RESTRICT_P (t)) { ch_restrict = "r"; }
+        fprintf (xdi->file, "%s_%d%s%s%s",
+                 (raises == TYPE_RAISES_EXCEPTIONS (ft))?"":" ",
+                 id, ch_const, ch_volatile, ch_restrict);
+        }
+      }
+    fprintf (xdi->file, "\"");
+    }
+}
+
 /* Print XML empty tag describing an unimplemented TREE_CODE that has been
    encountered.  */
 static void
@@ -871,6 +925,7 @@
   if(do_const)   xml_print_const_method_attribute (xdi, fd);
   if(do_virtual) xml_print_virtual_method_attributes (xdi, fd);
   if(do_static)  xml_print_static_method_attribute (xdi, fd);
+  xml_print_throw_attribute (xdi, TREE_TYPE (fd), dn->complete);
   xml_print_context_attribute (xdi, fd);
   xml_print_location_attribute (xdi, fd);
   xml_print_function_extern_attribute (xdi, fd);
@@ -1036,6 +1091,9 @@
     tree binfo = TYPE_BINFO (rt);
     tree binfos = BINFO_BASETYPES (binfo);
     int n_baselinks = binfos? TREE_VEC_LENGTH (binfos) : 0;
+#if !defined (XML_PRE_3_3_TREE_VIA_PUBLIC)
+    tree accesses = BINFO_BASEACCESSES (binfo);
+#endif
     int i;
     
     fprintf (xdi->file, " bases=\"");
@@ -1045,10 +1103,18 @@
       if (base_binfo)
         {
         /* Output this base class.  Default is public access.  */
+#if defined (XML_PRE_3_3_TREE_VIA_PUBLIC)
         const char* access = 0;
         if (TREE_VIA_PUBLIC (base_binfo)) { access = ""; }
         else if (TREE_VIA_PROTECTED (base_binfo)) { access = "protected:"; }
         else { access="private:"; }
+#else
+        tree n_access = (accesses ? TREE_VEC_ELT (accesses, i)
+                                  : access_public_node);
+        const char* access = "";
+        if (n_access == access_protected_node) { access = "protected:"; }
+        else if (n_access == access_private_node) { access = "private:"; }
+#endif
         
         fprintf (xdi->file, "%s_%d ", access,
                  xml_add_node (xdi, BINFO_TYPE (base_binfo), 1));
@@ -1397,7 +1463,11 @@
     switch (TREE_CODE (ts))
       {
       case TYPE_DECL:
-        xml_add_node (xdi, ts, complete);
+        /* Add the instantiation only if it is real.  */
+        if (!DECL_ARTIFICIAL(ts))
+          {
+          xml_add_node (xdi, ts, complete);
+          }
         break;
       default:
         /* xml_output_unimplemented (xdi, ts, 0,
@@ -1492,6 +1562,11 @@
     }
 }
 
+/* If we enabled xml dump debugging, undefine the macro.  */
+#if defined(xml_add_node)
+# undef xml_add_node
+#endif
+
 /* Add tree node N to those encountered.  Return its index.  */
 int
 xml_add_node (xml_dump_info_p xdi, tree n, int complete)
@@ -1556,8 +1631,8 @@
   for(fq = xdi->file_queue; fq ; fq = next_fq)
     {
     fprintf (xdi->file, "  <File id=\"f%d\" name=\"%s\"/>\n",
-             (unsigned int) fq->node->value,
-             IDENTIFIER_POINTER ((tree) fq->node->key));
+             (unsigned int) fq->tree_node->value,
+             IDENTIFIER_POINTER ((tree) fq->tree_node->key));
     next_fq = fq->next;
     free (fq);
     }

