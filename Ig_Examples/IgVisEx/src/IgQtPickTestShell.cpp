// IgQtPickTestShell.cpp: implementation of the IgQtPickTestShell class.
//
//////////////////////////////////////////////////////////////////////
#include "Ig_Examples/IgVisEx/interface/IgQtPickTestShell.h"
#include "Ig_Modules/IgVis/interface/IgQtMDI.h"
#include "Ig_Modules/IgVis/interface/IgQtMiscCtl.h"
#include "Ig_Modules/IgVis/interface/IgQtResourceMgr.h"
#include "Ig_Modules/IgVis/interface/IgQtPhysTabsImpl.h"
#include "Ig_Modules/IgVis/interface/IgQtViewpointCtl.h"
#include "Ig_Modules/IgVis/interface/IgQtViewpoint.h"
#include "Ig_Extensions/IgOpenInventor/interface/IgSoIdealTrack.h"
#include "Ig_Extensions/IgOpenInventor/interface/IgParticleChar.h"
#include "Ig_Modules/IgVis/interface/IgQtMDIShellBuilder.h"
#include "Ig_Modules/IgVis/interface/IgQtMDIShellFactory.h"

#include "Inventor/nodes/SoSelection.h"
#include "qpopupmenu.h"
#include "qstatusbar.h"
#include "qtabwidget.h"
#include "qapplication.h"
#if defined(emit)
#undef emit
#endif

#include "Ig_Examples/IgVisEx/interface/TestScene.h"
#include "Ig_Examples/IgVisEx/interface/TestTrack.h"
#include <Inventor/VRMLnodes/SoVRMLViewpoint.h>

class PickTestTwig : public IgQtLiveTwig<TestTrack>
{
public:
    explicit
	PickTestTwig (SbString name, bool visibility = true, bool cascade = true);
    //! method invoked whenever a child node of this twig is picked
    virtual void picked(SoNode *node, SoPath *path);
    virtual bool setControlWidget(QWidget *qtw);
    ~PickTestTwig();
private:
    //! internal list of objects we own
    std::list<TestTrack> *p_list;
};
PickTestTwig::PickTestTwig(SbString name, bool /*visibility*/, bool cascade) : IgQtLiveTwig<TestTrack>(name, cascade)
{
    p_list = new std::list<TestTrack>;
    p_list->push_back(TestTrack(1,1,0,sqrt(3.)));
    p_list->push_back(TestTrack(0,1,1,sqrt(3.)));
    p_list->push_back(TestTrack(1,0,1,sqrt(3.)));
    // Now simulate the process of looping over tracks, etc.
    int cnt = 0;
    for (  std::list<TestTrack>::const_iterator it = p_list->begin(); it != p_list->end(); it++, cnt++)
    {
	IgSoIdealTrack *kit = new IgSoIdealTrack;
	kit->initialise(0.,0.,0.,it->pX(),it->pY(),it->pZ(),0.F,14);
	insert(kit,&(*it));
    }


}
PickTestTwig::~PickTestTwig()
{
    if (p_list) delete p_list;
}
void PickTestTwig::picked(SoNode *node, SoPath *path)
{
    std::ostream &ostr = *getOstream();
    ostr << "Picked!"<< std::endl;
    IgSoIdealTrack *k = dynamic_cast<IgSoIdealTrack *>(node);
    if (k) 
    {
	ostr << "Particle: " << k->particleType.getValue().getString() << std::endl;
	ostr << "Ptot: " << k->ptot() << " GeV, Pt: " << k-> pt() << " GeV" << std::endl;
	ostr << "Radius of curvature: " << k->radius.getValue() << "m" << std::endl;
	ostr << "Zeta: " << k->zeta.getValue() << std::endl;
	SbVec3f vertex = k->vertex.getValue();
	ostr << "Vertex (x/y/z in m): "<<  vertex[0] <<", "<< vertex[1] <<", " << vertex[2] << std::endl;
	ostr << "Phi: " << k->phi.getValue() << std::endl;
	ostr << "T0:       " << k->t0.getValue() << std::endl;
	ostr << "DeltaT is " << k->dt.getValue() << std::endl;
    }

    // get the head of the path (should be the SoSelection which fired)
    SoNode *head = path->getHead();		
    if (head->isOfType(SoSelection::getClassTypeId()))
    {
	SoSelection *select = static_cast<SoSelection*>(head);
	const SoPathList *pathList = select->getList();
	int num_lists = pathList->getLength();
	if (num_lists == 2)
	{
	    *getOstream() << "Two nodes selected" << std::endl;

	    //			Get physics data for this twig
	    const TestTrack *t1 = dataElement(node);
	    //			Get physics data for other selected object
	    SoPath *path2 = (*pathList)[0];
	    IgQtTwig *twigX = findTwigInPath(path2);
	    // check for success and type
	    if (twigX)
	    {
		PickTestTwig *tt = dynamic_cast<PickTestTwig*>(twigX);
		if (tt)
		{
		    const TestTrack *t2 = tt->dataElement(path2->getTail());
		    *getOstream() << "Invariant Mass = " << TestTrack::invMass(*t1,*t2) << std::endl;
		}
	    }
	}
    }
}
bool PickTestTwig::setControlWidget(QWidget * /*qtw*/)
{
    return false;
}



const QString IgQtPickTestShell::theShellName = QString( "IgQtPickTestShell" );
namespace {
    IgQtShellRegisterEntry e( QString( "IgQtPickTestShell" ), IgQtMDIShellBuilder<IgQtPickTestShell>::getInstance(), QString( "Pick Test" ) );
}

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

IgQtPickTestShell::IgQtPickTestShell( IgQtMDI* parent, SoQtFullViewer* aViewer ) :
IgQtMDIBaseShell( parent, aViewer )
{
    setUniqueName(theShellName); //overwrites the name generated by AbsShell
    event_number = 0; // a dummy event counter
    eventInput = NULL; // file of dummy events
    file->insertItem( "Build Scene", this, SLOT(buildSlot()));
    setCaption( "Pick Test" );

    SoVRMLViewpoint *vOne = new SoVRMLViewpoint;
    vOne->position = SbVec3f(-18.9909, 8.54639, 5.2616);
    vOne->orientation = SbRotation(-0.236382, -0.567138, -0.0220663, 0.788664);
    vOne->fieldOfView = 0.785398;
    vOne->description = "TestView";
    IgQtViewpoint vp(vOne);
    vp.label = "Pre-Existing";
    if (views->addIvItem(vp, QString("TestView"))) topTwig->getIvNode()->addChild(vOne);

    parent->addBrowser( this );

}

IgQtPickTestShell::~IgQtPickTestShell()
{
}

void IgQtPickTestShell::buildSlot()
{
    PickTestTwig *root = new PickTestTwig("PickTest");
    addStaticTwig(root);
    // instead of using adorn, we just add an InfoWidget
    addInfoStreamWidget(root);

    root->setControlWidget(tabs->tabWidget);
    setCaption("TestScene");

}

void IgQtPickTestShell::eventsSlot()
{
    // we have to get our own events. normally we would just pass on a request and do the clean-up
    // in eventNotifySlot
    IgQtMDIBaseShell::eventsSlot();
    QStatusBar* aBar = this->statusBar();
    QApplication::setOverrideCursor( waitCursor );
    // if we had more than one event in the file, should be able to make a static input and re-read
    // to get the next event
    if( !eventInput ) 
    {
	eventInput = new SoInput;
	eventInput->openFile( "ThreeEvents.iv" );
    }

    if( eventInput->isValidFile()) 
    {		
	SoNode* node;
	if( SoDB::read( eventInput, node ) && node ) 
	{
	    QString theCaption( "Event_" );
	    QString num;
	    theCaption += num.setNum( event_number++ );
	    setCaption( theCaption );

	    IgQtTwig* tree = IgQtTwig::addTwigFromScratch( node, false ); //will recurse down
	    addVolatileTwig( tree );
	}
	else //assume we've hit EOF
	{
	    eventInput->closeFile();
	    eventInput->openFile( "ThreeEvents.iv" );
	    //			SoNode *node;
	    if( SoDB::read( eventInput, node )) 
	    {
		QString theCaption( "Event_" );

		QString num;
		theCaption += num.setNum( event_number++ );
		setCaption( theCaption );

		IgQtTwig* tree = IgQtTwig::addTwigFromScratch( node, false ); //will recurse down
		addVolatileTwig( tree );
	    }
	    else
	    {
		exit (0); // a bit drastic, eh wot?
	    }
	}
    }
    aBar->message( "Got Event", 2000 );
    QApplication::restoreOverrideCursor();
}
void IgQtPickTestShell::eventNotifySlot()
{
}
const QString IgQtPickTestShell::shellName()
{
	return theShellName;
}











