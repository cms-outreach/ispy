// IgQtMDITest2DShell.cpp: implementation of the IgQtMDITest2DShell class.
//
//////////////////////////////////////////////////////////////////////

#include "Ig_Examples/IgVisEx/interface/IgQtMDITest2DShell.h"

#include <Inventor/Qt/viewers/SoQtPlaneViewer.h>
#include <Inventor/nodes/SoSelection.h>
#include <Inventor/actions/SoBoxHighlightRenderAction.h>
#include "Ig_Modules/IgVis/interface/IgQtMDI.h"
#include "Ig_Modules/IgVis/interface/IgQtTwig.h"
#include "Ig_Modules/IgVis/interface/IgQtTwigCallbackStruct.h"
#include "Ig_Modules/IgVis/interface/IgQt2DViewer.h"

#include "Ig_Modules/IgVis/interface/IgQtMiscCtl.h"
#include "Ig_Modules/IgVis/interface/IgQtResourceMgr.h"

#include "qpopupmenu.h"
#include "qstatusbar.h"

#include "Ig_Examples/IgVisEx/interface/TestScene.h"
#include "Ig_Examples/IgVisEx/interface/GenericEvent.h"
#include "Ig_Modules/IgVis/interface/IgQtTwig.h"
#include "Ig_Modules/IgVis/interface/IgQtTwig2D.h"
#include "Ig_Modules/IgVis/interface/IgQtVectorTwig.h"
#include "Ig_Modules/IgVis/interface/IgQtLayer.h"
#include "Ig_Modules/IgVis/interface/IgQtBrowser.h"
#include "Ig_Modules/IgVis/interface/IgQtVisCtl.h"
#include "Ig_Modules/IgVis/interface/IgQtMDIShellBuilder.h"
#include "Ig_Modules/IgVis/interface/IgQtMDIShellFactory.h"

#include <Inventor/nodes/SoSeparator.h>
#include <Inventor/nodes/SoCube.h>
#include <Inventor/nodes/SoTranslation.h>
#include <Inventor/nodes/SoTransform.h>
#include <Inventor/nodes/SoMarkerSet.h>
#include <Inventor/nodes/SoSwitch.h>
#include <Inventor/SoPath.h>
#include <Inventor/actions/SoSearchAction.h>
#include <Inventor/nodes/SoScale.h>
#include <Inventor/nodes/SoCube.h>
#include <Inventor/nodes/SoCylinder.h>
#include <Inventor/nodes/SoTranslation.h>
#include <Inventor/nodes/SoMaterial.h>
#include <Inventor/nodes/SoFaceSet.h>
#include <Inventor/nodes/SoVertexShape.h>
#include <Inventor/nodes/SoLineSet.h>
#include <Inventor/nodes/SoFont.h>
#include <Inventor/nodes/SoText3.h>
#include <Inventor/nodes/SoSphere.h>
#include <Inventor/nodes/SoCamera.h>
#include <Inventor/nodes/SoMaterialBinding.h>

#ifdef __KCC
#define __hpux
#endif
#include <Inventor/nodes/SoIndexedFaceSet.h>

//
// private test class
//

class TestScene2D : public IgQtTwig2D
{

public:
    //! only arg is the output stream; all else from Twig
    explicit TestScene2D(std::ostream &stream = std::cout, const bool build=true);
    //! d-tor
    virtual ~TestScene2D(){};
protected:
    void setList(std::list<TestObject> *pl){if (p_list) delete p_list; p_list = pl;} //leaks like a sieve: use w/ care
    void setVector(std::vector<TestObject> *pv){if (p_vector) delete p_vector; p_vector = pv;} // ditto
    void buildScene();
private:
    //! internal list of objects we own
    std::list<TestObject> *p_list;
    std::vector<TestObject> *p_vector;
};

class IgSoRectangle : public SoIndexedFaceSet
{
public:
    IgSoRectangle(float dx = 1.F, float dy = 1.F);
    ~IgSoRectangle(){};
};
IgSoRectangle::IgSoRectangle(float dx, float dy)
{
    SoVertexProperty *vp = new SoVertexProperty;
    std::vector<SbVec3f> verts(4);
    std::vector<int> indices(5);

    verts[0] = SbVec3f(-dx/2, -dy/2, 0.F);
    verts[1] = SbVec3f( dx/2, -dy/2, 0.F);
    verts[2] = SbVec3f( dx/2,  dy/2, 0.F);
    verts[3] = SbVec3f(-dx/2,  dy/2, 0.F);

    for (int i=0; i < 4; i++) indices[i] = i;
    indices[4] = SO_END_FACE_INDEX;

    int nindices = 0;

    vp->materialBinding.setValue(SoMaterialBinding::OVERALL);
    vp->normalBinding.setValue(SoMaterialBinding::PER_FACE_INDEXED);
    vp->vertex.setValues(0,static_cast<int>(verts.size()),&verts[0]);
    vp->normal.setValue(SbVec3f(0.F,0.F,1.F));
    coordIndex.setValues(0,5,&indices[0]);
    normalIndex.setValues(0,1,&nindices);
    vertexProperty = vp;
}

const QString IgQtMDITest2DShell::theShellName = QString("IgQtMDITest2DShell");
namespace {
    IgQtShellRegisterEntry e( std::string("IgQtMDITest2DShell"), IgQtMDIShellBuilder<IgQtMDITest2DShell>::getInstance(), QString("Test Shell (2D)") );
}

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

IgQtMDITest2DShell::IgQtMDITest2DShell(IgQtMDI *parent, SoQtFullViewer* /* aViewer */):
IgQtMDIBaseShell(parent,NULL,false)
{	
    setUniqueName(theShellName); //overwrites the name generated by AbsShell
    QWidget *view = new QWidget(this);
    setCentralWidget(view);
    theViewer = new IgQt2DViewer( view,"Iguana 2D Demo");
    IgQtMDIBaseShell::buildWidget(view);

    // Replace standard sceneTwig with a 2D version
    // must remove callbacks before removing old sceneTwig
    if (sceneTwig && sceneTwig->getIvNode()->getTypeId().isDerivedFrom(SoSelection::getClassTypeId())) 
    {
	theViewer->redrawOnSelectionChange(NULL);
    }
    topTwig->removeChild(sceneTwig);
    // add the new 2D scene
    IgQtTwig2D *tempScene = new IgQtTwig2D("Scene");
    // want scene to be selectable for picking
    tempScene->makeSelectable();
    sceneTwig = tempScene;
    topTwig->addChild(sceneTwig);

    IgQtTwigCallbackStruct *selectCBStruct = 
	new IgQtTwigCallbackStruct(sceneTwig,theViewer->getSceneManager());
    if (sceneTwig->getIvNode()->getTypeId().isDerivedFrom(SoSelection::getClassTypeId())) 
    {
	SoSelection *selectNode = static_cast<SoSelection*>(sceneTwig->getIvNode());
	selectNode->policy.setValue(SoSelection::SHIFT);
	selectNode->addSelectionCallback(IgQtTwig::selectionCB, selectCBStruct);
	selectNode->setPickFilterCallback(IgQtTwig::pickCB, selectCBStruct);
	theViewer->redrawOnSelectionChange(selectNode);
    }

    file->insertItem( "Build Scene", this, SLOT(buildSlot()));
    lights->allOff(); // make sure default is no lights
    setCaption( theShellName );
    parentMDI->addBrowser( this );

}
void IgQtMDITest2DShell::buildSlot()
{
    TestScene2D *testScene = new TestScene2D;
    addStaticTwig(testScene,"TestScene");
    // kick-start the resize: for twigs constructed statically, the drawMe is not performed
    adornSlot();

    // event is dynamic
    IgQtTwig2D *event = new IgQtTwig2D("Event");
    event->addChild(new Event);

    addVolatileTwig ( event );
    IgQtTwig2D *t = dynamic_cast<IgQtTwig2D*>(sceneTwig);
    testScene->resize();
    t->resize();

    setCaption("2D Test Scene");
}
IgQtMDITest2DShell::~IgQtMDITest2DShell()
{

}
TestScene2D::TestScene2D(std::ostream & /* stream */, const bool build): IgQtTwig2D("2DTestTwig"), p_list(0), p_vector(0)
{
    if (build) buildScene(); 
}
void TestScene2D::buildScene()
{

    // add some two D content in the form objects which don't overlap internally (but may externally)
    SoSeparator *sep = new SoSeparator;
    IgSoRectangle *cube = new IgSoRectangle(2.F,2.F);
    SoMaterial *mat = new SoMaterial;
    mat->emissiveColor = SbColor(1.0,0.,0.);
    sep->addChild(mat);
    sep->addChild(cube);
    add2dIvNode(sep);

    sep = new SoSeparator;
    SoTranslation *trans = new SoTranslation;
    trans->translation = SbVec3f(1.F,0.F,0.F);
    mat = new SoMaterial;
    mat->emissiveColor = SbColor(0.F,1.F,0.F);
    sep->addChild(mat);
    sep->addChild(trans);
    sep->addChild(cube);

    add2dIvNode(sep);

    const int npoints = 5;
    sep = new SoSeparator;
    trans = new SoTranslation;
    trans->translation = SbVec3f(1.0F,0.F,0.F);
    mat = new SoMaterial;
    mat->emissiveColor = SbColor(0.F,0.F,1.F);
    sep->addChild(mat);
    sep->addChild(trans);
    SoFaceSet *star = new SoFaceSet;
    star->numVertices = 2*npoints;
    SoMFVec3f pts;
    pts.setNum(2*npoints+1);
    const float r = 1.F, two_pi = 2 * 3.14159266;
    const float del_angle = two_pi/npoints;
    float angle = del_angle/2;
    float x=0.F, y=0.F, z=0.F;
    SoSeparator *subSep;
    SoTranslation *ptTranslate;
    SoSphere *ptSphere = new SoSphere;
    ptSphere->radius = 0.1;
    for (int ii=0; ii<npoints; ii++, angle -= del_angle)
    {
	x = 0.5 * r * cos(angle); y = 0.5 * r * sin(angle);
	pts.set1Value(2*ii,x,y,z);
	ptTranslate = new SoTranslation;
	ptTranslate->translation = SbVec3f(x,y,z);
	subSep = new SoSeparator;
	sep->addChild(subSep);
	subSep->addChild(ptTranslate);
	subSep->addChild(ptSphere);

	x = r * cos(angle-del_angle/2.); y = r * sin(angle-del_angle/2.);
	pts.set1Value(2*ii+1,x,y,z);
	ptTranslate = new SoTranslation;
	ptTranslate->translation = SbVec3f(x,y,z);
	subSep = new SoSeparator;
	sep->addChild(subSep);
	subSep->addChild(ptTranslate);
	subSep->addChild(ptSphere);
    }
    SoVertexProperty *vert = new SoVertexProperty;
    vert->vertex = pts;
    vert->normalBinding.setValue(SoMaterialBinding::OVERALL);
    vert->normal.setValue(SbVec3f(0.F,0.F,1.F));
    star->vertexProperty = vert;
    sep->addChild(star);

    SoLineSet *lines = new SoLineSet;
    lines->numVertices = 2*npoints+1;
    SoVertexProperty *lineVert = new SoVertexProperty;
    pts.set1Value(2*npoints,pts[0]); //this is only safe if pts isn't required to expand
    lineVert->vertex = pts;
    lines->vertexProperty = lineVert;
    sep->addChild(lines);

    add2dIvNode(sep);


    sep = new SoSeparator;
    SoFont *font = new SoFont;
    font->size=0.3;
    mat = new SoMaterial;
    //  only emissive color shows up in the Postscript
    //TODO: seems there's still some problem with the underlying face set taking precedence over the text
    mat->emissiveColor = SbColor(0.1F,0.1F,0.1F);
    SoText3 *text= new SoText3;
    text->string = "CMS & D0";
    sep->addChild(mat);
    sep->addChild(font);
    sep->addChild(text);
    SoTranslation *textTrans = new SoTranslation;
    textTrans->translation = SbVec3f(0.F,-0.3F,0.F);
    sep->addChild(textTrans);
    SoFont *syFont = new SoFont;
    syFont->name = "Symbol";
    syFont->size = 0.3;
    sep->addChild(syFont);
    sep->addChild(text);

    add2dIvNode(sep);

    // Now put in an object which is indexed
    // 
    // Use a vector just as a change...
    const float armLength = 1.2; //length of radius to boxes

    std::vector<TestObject> *pv = new std::vector<TestObject>;
    const int nStars = 12;
    for (int i=0; i < nStars; i++) {
	pv->push_back(TestObject(i));
    }
    setVector(pv);
    // Create the graphics node for the twig
    SoMarkerSet *markerSet = new SoMarkerSet;
    SoVertexProperty *vertexProperty = new SoVertexProperty;
    SbColor markerColor(0.F,1.F,0.F);
    vertexProperty->orderedRGBA.set1Value(0,markerColor.getPackedValue());
    SoMFVec3f vertices;
    int nVertices = 0;
    const float radius = 2 * armLength;
    for ( std::vector<TestObject>::const_iterator it = pv->begin(); it != pv->end(); it++)
    {
	angle = (*it).getData()*2*M_PI/nStars;
	SbVec3f aPoint(radius*cos(angle), radius*sin(angle),0.F);
	vertices.set1Value(nVertices++,aPoint);
    }
    vertexProperty->vertex = vertices;
    markerSet->vertexProperty = vertexProperty;
    markerSet->markerIndex = SoMarkerSet::CIRCLE_FILLED_7_7;

    // Create the twig
    IgQtVectorTwig<TestObject> *p_vTwig = new IgQtVectorTwig<TestObject>(pv,"Point Objects",false);
    p_vTwig->insert(markerSet);





    //  Insert some other objects behind the vectored twig
    IgQtLayer *ll = new IgQtLayer;
    SoMaterial *mm = new SoMaterial;
    mm->emissiveColor = SbColor(1.0F,0.5F,0.F);
    ll->addChild(mm);
    SoCylinder *cyl = new SoCylinder;
    cyl->parts = SoCylinder::TOP;
    cyl->radius = 0.2F;
    cyl->height = 0.F;
    angle = 0.F;
    for (int i=0; i < nStars; i++, angle += 2*M_PI/nStars)
    {
	SoSeparator *ssep = new SoSeparator;
	SoTransform *trans = new SoTransform;
	trans->translation = SbVec3f(radius*cos(angle),radius*sin(angle),0);
	trans->rotation = SbRotation(SbVec3f(1.F,0.F,0.F),M_PI/2.F);
	ssep->addChild(trans);
	ssep->addChild(cyl);
	ll->add2dChild(ssep);
    }
    addLayer(ll);

    //  add the vectored layer to the test scene
    addChild(p_vTwig);

    return;
}
const QString IgQtMDITest2DShell::shellName()
{
    return theShellName;
}
